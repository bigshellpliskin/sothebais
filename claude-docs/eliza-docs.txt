<page>
  <title>Introduction to Eliza | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/intro</url>
  <content>_As seen powering [@DegenSpartanAI](https://x.com/degenspartanai) and [@MarcAIndreessen](https://x.com/pmairca)_

What is Eliza?[​](#what-is-eliza "Direct link to What is Eliza?")
-----------------------------------------------------------------

Eliza is a powerful multi-agent simulation framework designed to create, deploy, and manage autonomous AI agents. Built with TypeScript, it provides a flexible and extensible platform for developing intelligent agents that can interact across multiple platforms while maintaining consistent personalities and knowledge.

Key Features[​](#key-features "Direct link to Key Features")
------------------------------------------------------------

### Core Capabilities[​](#core-capabilities "Direct link to Core Capabilities")

*   **Multi-Agent Architecture**: Deploy and manage multiple unique AI personalities simultaneously
*   **Character System**: Create diverse agents using the [characterfile](https://github.com/lalalune/characterfile/) framework
*   **Memory Management**: Advanced RAG (Retrieval Augmented Generation) system for long-term memory and context awareness
*   **Platform Integration**: Seamless connectivity with Discord, Twitter, and other platforms

### Communication & Media[​](#communication--media "Direct link to Communication & Media")

*   **Multi-Platform Support**:
    
    *   Full-featured Discord integration with voice channel support
    *   Twitter/X bot capabilities
    *   Telegram integration
    *   Direct API access
*   **Media Processing**:
    
    *   PDF document reading and analysis
    *   Link content extraction and summarization
    *   Audio transcription
    *   Video content processing
    *   Image analysis and description
    *   Conversation summarization

### AI & Technical Features[​](#ai--technical-features "Direct link to AI & Technical Features")

*   **Flexible Model Support**:
    
    *   Local inference with open-source models
    *   Cloud-based inference through OpenAI
    *   Default configuration with Nous Hermes Llama 3.1B
    *   Integration with Claude for complex queries
*   **Technical Foundation**:
    
    *   100% TypeScript implementation
    *   Modular architecture
    *   Extensible action system
    *   Custom client support
    *   Comprehensive API

Use Cases[​](#use-cases "Direct link to Use Cases")
---------------------------------------------------

Eliza can be used to create:

1.  **AI Assistants**
    
    *   Customer support agents
    *   Community moderators
    *   Personal assistants
2.  **Social Media Personas**
    
    *   Automated content creators
    *   Engagement bots
    *   Brand representatives
3.  **Knowledge Workers**
    
    *   Research assistants
    *   Content analysts
    *   Document processors
4.  **Interactive Characters**
    
    *   Role-playing characters
    *   Educational tutors
    *   Entertainment bots

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

Eliza is designed to be accessible while maintaining powerful capabilities:

*   **Quick Start**: Begin with basic configuration and default character
*   **Customization**: Extend functionality through custom actions and clients
*   **Scaling**: Deploy multiple agents with different personalities
*   **Integration**: Connect to various platforms and services

Check out our [Quickstart Guide](https://elizaos.github.io/eliza/docs/quickstart/) to begin your journey with Eliza.

Architecture Overview[​](#architecture-overview "Direct link to Architecture Overview")
---------------------------------------------------------------------------------------

Community and Support[​](#community-and-support "Direct link to Community and Support")
---------------------------------------------------------------------------------------

Eliza is backed by an active community of developers and users:

*   **Open Source**: Contribute to the project on [GitHub](https://github.com/elizaos/eliza)
*   **Documentation**: Comprehensive guides and API references
*   **Examples**: Ready-to-use character templates and implementations
*   **Support**: Active community for troubleshooting and discussion

Next Steps[​](#next-steps "Direct link to Next Steps")
------------------------------------------------------

*   [Create Your First Agent](https://elizaos.github.io/eliza/docs/quickstart/)
*   [Understand Core Concepts](https://elizaos.github.io/eliza/docs/core/agents/)
*   [Explore Advanced Features](https://elizaos.github.io/eliza/docs/guides/advanced/)

Join us in building the future of autonomous AI agents with Eliza!</content>
</page>

<page>
  <title>Introduction to Eliza | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/intro/</url>
  <content>_As seen powering [@DegenSpartanAI](https://x.com/degenspartanai) and [@MarcAIndreessen](https://x.com/pmairca)_

What is Eliza?[​](#what-is-eliza "Direct link to What is Eliza?")
-----------------------------------------------------------------

Eliza is a powerful multi-agent simulation framework designed to create, deploy, and manage autonomous AI agents. Built with TypeScript, it provides a flexible and extensible platform for developing intelligent agents that can interact across multiple platforms while maintaining consistent personalities and knowledge.

Key Features[​](#key-features "Direct link to Key Features")
------------------------------------------------------------

### Core Capabilities[​](#core-capabilities "Direct link to Core Capabilities")

*   **Multi-Agent Architecture**: Deploy and manage multiple unique AI personalities simultaneously
*   **Character System**: Create diverse agents using the [characterfile](https://github.com/lalalune/characterfile/) framework
*   **Memory Management**: Advanced RAG (Retrieval Augmented Generation) system for long-term memory and context awareness
*   **Platform Integration**: Seamless connectivity with Discord, Twitter, and other platforms

### Communication & Media[​](#communication--media "Direct link to Communication & Media")

*   **Multi-Platform Support**:
    
    *   Full-featured Discord integration with voice channel support
    *   Twitter/X bot capabilities
    *   Telegram integration
    *   Direct API access
*   **Media Processing**:
    
    *   PDF document reading and analysis
    *   Link content extraction and summarization
    *   Audio transcription
    *   Video content processing
    *   Image analysis and description
    *   Conversation summarization

### AI & Technical Features[​](#ai--technical-features "Direct link to AI & Technical Features")

*   **Flexible Model Support**:
    
    *   Local inference with open-source models
    *   Cloud-based inference through OpenAI
    *   Default configuration with Nous Hermes Llama 3.1B
    *   Integration with Claude for complex queries
*   **Technical Foundation**:
    
    *   100% TypeScript implementation
    *   Modular architecture
    *   Extensible action system
    *   Custom client support
    *   Comprehensive API

Use Cases[​](#use-cases "Direct link to Use Cases")
---------------------------------------------------

Eliza can be used to create:

1.  **AI Assistants**
    
    *   Customer support agents
    *   Community moderators
    *   Personal assistants
2.  **Social Media Personas**
    
    *   Automated content creators
    *   Engagement bots
    *   Brand representatives
3.  **Knowledge Workers**
    
    *   Research assistants
    *   Content analysts
    *   Document processors
4.  **Interactive Characters**
    
    *   Role-playing characters
    *   Educational tutors
    *   Entertainment bots

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

Eliza is designed to be accessible while maintaining powerful capabilities:

*   **Quick Start**: Begin with basic configuration and default character
*   **Customization**: Extend functionality through custom actions and clients
*   **Scaling**: Deploy multiple agents with different personalities
*   **Integration**: Connect to various platforms and services

Check out our [Quickstart Guide](https://elizaos.github.io/eliza/docs/quickstart/) to begin your journey with Eliza.

Architecture Overview[​](#architecture-overview "Direct link to Architecture Overview")
---------------------------------------------------------------------------------------

Community and Support[​](#community-and-support "Direct link to Community and Support")
---------------------------------------------------------------------------------------

Eliza is backed by an active community of developers and users:

*   **Open Source**: Contribute to the project on [GitHub](https://github.com/elizaos/eliza)
*   **Documentation**: Comprehensive guides and API references
*   **Examples**: Ready-to-use character templates and implementations
*   **Support**: Active community for troubleshooting and discussion

Next Steps[​](#next-steps "Direct link to Next Steps")
------------------------------------------------------

*   [Create Your First Agent](https://elizaos.github.io/eliza/docs/quickstart/)
*   [Understand Core Concepts](https://elizaos.github.io/eliza/docs/core/agents/)
*   [Explore Advanced Features](https://elizaos.github.io/eliza/docs/guides/advanced/)

Join us in building the future of autonomous AI agents with Eliza!</content>
</page>

<page>
  <title>Introduction | eliza</title>
  <url>https://elizaos.github.io/eliza/community/</url>
  <content>*   [](https://elizaos.github.io/eliza/)
*   Introduction

Welcome to the ai16z / ElizaOS Community
----------------------------------------

ai16z is a pioneering venture capital firm that operates as a decentralized autonomous organization (DAO), leveraging the power of artificial intelligence to revolutionize investment strategies and foster an open-source community around AI agents.

Our Mission[​](#our-mission "Direct link to Our Mission")
---------------------------------------------------------

Our mission is to drive innovation at the intersection of AI and blockchain technology by harnessing the collective intelligence of our community and the capabilities of cutting-edge AI agents. We aim to make informed investment decisions, support groundbreaking projects, and accelerate the development and adoption of AI across various domains.

The ElizaOS Framework[​](#the-elizaos-framework "Direct link to The ElizaOS Framework")
---------------------------------------------------------------------------------------

At the core of ai16z lies ElizaOS, an open-source framework designed for creating, deploying, and managing AI agents. These agents, known as "elizas," are versatile entities capable of engaging across various platforms, including Discord, Twitter, and Telegram.

With ElizaOS, developers can:

*   Build flexible agents with unique personalities and behaviors
*   Leverage modular design to enhance agents with specialized "actions"
*   Scale with ease by creating multi-agent systems
*   Develop with accessibility using an extensible framework

ElizaOS empowers developers of all skill levels to harness the potential of AI agent technology and contribute to the advancement of the ai16z ecosystem.

Governance[​](#governance "Direct link to Governance")
------------------------------------------------------

ai16z originates as being an AI agent led DAO. Similar to how we can influence the autonomous agents on memecoins to buy, we intend to bring similar functionality for token holders to actively participate in the decision-making process and shape the future of the project. Community members can pitch ideas, provide insights, and influence investment strategies based on their expertise and track record.

Explore and Contribute[​](#explore-and-contribute "Direct link to Explore and Contribute")
------------------------------------------------------------------------------------------

We invite you to explore the various sections of our documentation to learn more about ai16z, the ElizaOS framework, and how you can get involved:

*   [AI Agent Dev School](https://elizaos.github.io/eliza/community/ai-dev-school/): Start your journey with our comprehensive series on agent development
*   [Tutorials](https://elizaos.github.io/eliza/tutorials/): Follow step-by-step guides to build and integrate AI agents
*   [API Reference](https://elizaos.github.io/eliza/api/): Explore the ElizaOS API documentation
*   [Contributing Guide](https://elizaos.github.io/eliza/community/contributing/): Learn how you can contribute to ElizaOS
*   [Roadmap](https://elizaos.github.io/eliza/community/roadmap/): Discover future plans and priorities for ElizaOS development
*   [Community Showcase](https://elizaos.github.io/eliza/community/showcase/): Get inspired by projects built with ElizaOS and share your own creations
*   [Events and Updates](https://elizaos.github.io/eliza/community/streams/): Stay informed about the latest happenings in the ai16z community
*   [FAQ and Support](https://elizaos.github.io/eliza/community/faq-and-support/): Find answers to common questions and get support

Join us on this exciting journey as we push the boundaries of what's possible with AI and decentralized technologies. Together, let's build a future powered by intelligent, autonomous agents.

[](https://elizaos.github.io/eliza/community/creator-fund/)

*   [Our Mission](#our-mission)
*   [The ElizaOS Framework](#the-elizaos-framework)
*   [Governance](#governance)
*   [Explore and Contribute](#explore-and-contribute)</content>
</page>

<page>
  <title>@elizaos/core v0.1.7-alpha.2 | eliza</title>
  <url>https://elizaos.github.io/eliza/api/</url>
  <content>*   [](https://elizaos.github.io/eliza/)
*   @elizaos/core v0.1.7-alpha.2

Enumerations[​](#enumerations "Direct link to Enumerations")
------------------------------------------------------------

*   [GoalStatus](https://elizaos.github.io/eliza/api/enumerations/GoalStatus/)
*   [ModelClass](https://elizaos.github.io/eliza/api/enumerations/ModelClass/)
*   [ModelProviderName](https://elizaos.github.io/eliza/api/enumerations/ModelProviderName/)
*   [Clients](https://elizaos.github.io/eliza/api/enumerations/Clients/)
*   [CacheStore](https://elizaos.github.io/eliza/api/enumerations/CacheStore/)
*   [ServiceType](https://elizaos.github.io/eliza/api/enumerations/ServiceType/)
*   [LoggingLevel](https://elizaos.github.io/eliza/api/enumerations/LoggingLevel/)
*   [TranscriptionProvider](https://elizaos.github.io/eliza/api/enumerations/TranscriptionProvider/)

Classes[​](#classes "Direct link to Classes")
---------------------------------------------

*   [MemoryCacheAdapter](https://elizaos.github.io/eliza/api/classes/MemoryCacheAdapter/)
*   [FsCacheAdapter](https://elizaos.github.io/eliza/api/classes/FsCacheAdapter/)
*   [DbCacheAdapter](https://elizaos.github.io/eliza/api/classes/DbCacheAdapter/)
*   [CacheManager](https://elizaos.github.io/eliza/api/classes/CacheManager/)
*   [DatabaseAdapter](https://elizaos.github.io/eliza/api/classes/DatabaseAdapter/)
*   [MemoryManager](https://elizaos.github.io/eliza/api/classes/MemoryManager/)
*   [AgentRuntime](https://elizaos.github.io/eliza/api/classes/AgentRuntime/)
*   [Service](https://elizaos.github.io/eliza/api/classes/Service/)

Interfaces[​](#interfaces "Direct link to Interfaces")
------------------------------------------------------

*   [ICacheAdapter](https://elizaos.github.io/eliza/api/interfaces/ICacheAdapter/)
*   [GenerationOptions](https://elizaos.github.io/eliza/api/interfaces/GenerationOptions/)
*   [Content](https://elizaos.github.io/eliza/api/interfaces/Content/)
*   [ActionExample](https://elizaos.github.io/eliza/api/interfaces/ActionExample/)
*   [ConversationExample](https://elizaos.github.io/eliza/api/interfaces/ConversationExample/)
*   [Actor](https://elizaos.github.io/eliza/api/interfaces/Actor/)
*   [Objective](https://elizaos.github.io/eliza/api/interfaces/Objective/)
*   [Goal](https://elizaos.github.io/eliza/api/interfaces/Goal/)
*   [State](https://elizaos.github.io/eliza/api/interfaces/State/)
*   [Memory](https://elizaos.github.io/eliza/api/interfaces/Memory/)
*   [MessageExample](https://elizaos.github.io/eliza/api/interfaces/MessageExample/)
*   [Action](https://elizaos.github.io/eliza/api/interfaces/Action/)
*   [EvaluationExample](https://elizaos.github.io/eliza/api/interfaces/EvaluationExample/)
*   [Evaluator](https://elizaos.github.io/eliza/api/interfaces/Evaluator/)
*   [Provider](https://elizaos.github.io/eliza/api/interfaces/Provider/)
*   [Relationship](https://elizaos.github.io/eliza/api/interfaces/Relationship/)
*   [Account](https://elizaos.github.io/eliza/api/interfaces/Account/)
*   [Participant](https://elizaos.github.io/eliza/api/interfaces/Participant/)
*   [Room](https://elizaos.github.io/eliza/api/interfaces/Room/)
*   [IAgentConfig](https://elizaos.github.io/eliza/api/interfaces/IAgentConfig/)
*   [ModelConfiguration](https://elizaos.github.io/eliza/api/interfaces/ModelConfiguration/)
*   [IDatabaseAdapter](https://elizaos.github.io/eliza/api/interfaces/IDatabaseAdapter/)
*   [IDatabaseCacheAdapter](https://elizaos.github.io/eliza/api/interfaces/IDatabaseCacheAdapter/)
*   [IMemoryManager](https://elizaos.github.io/eliza/api/interfaces/IMemoryManager/)
*   [ICacheManager](https://elizaos.github.io/eliza/api/interfaces/ICacheManager/)
*   [IAgentRuntime](https://elizaos.github.io/eliza/api/interfaces/IAgentRuntime/)
*   [IImageDescriptionService](https://elizaos.github.io/eliza/api/interfaces/IImageDescriptionService/)
*   [ITranscriptionService](https://elizaos.github.io/eliza/api/interfaces/ITranscriptionService/)
*   [IVideoService](https://elizaos.github.io/eliza/api/interfaces/IVideoService/)
*   [ITextGenerationService](https://elizaos.github.io/eliza/api/interfaces/ITextGenerationService/)
*   [IBrowserService](https://elizaos.github.io/eliza/api/interfaces/IBrowserService/)
*   [ISpeechService](https://elizaos.github.io/eliza/api/interfaces/ISpeechService/)
*   [IPdfService](https://elizaos.github.io/eliza/api/interfaces/IPdfService/)
*   [IAwsS3Service](https://elizaos.github.io/eliza/api/interfaces/IAwsS3Service/)
*   [ActionResponse](https://elizaos.github.io/eliza/api/interfaces/ActionResponse/)
*   [ISlackService](https://elizaos.github.io/eliza/api/interfaces/ISlackService/)

Type Aliases[​](#type-aliases "Direct link to Type Aliases")
------------------------------------------------------------

*   [EmbeddingProviderType](https://elizaos.github.io/eliza/api/type-aliases/EmbeddingProviderType/)
*   [EmbeddingConfig](https://elizaos.github.io/eliza/api/type-aliases/EmbeddingConfig/)
*   [EnvConfig](https://elizaos.github.io/eliza/api/type-aliases/EnvConfig/)
*   [CharacterConfig](https://elizaos.github.io/eliza/api/type-aliases/CharacterConfig/)
*   [UUID](https://elizaos.github.io/eliza/api/type-aliases/UUID/)
*   [Model](https://elizaos.github.io/eliza/api/type-aliases/Model/)
*   [Models](https://elizaos.github.io/eliza/api/type-aliases/Models/)
*   [Handler](https://elizaos.github.io/eliza/api/type-aliases/Handler/)
*   [HandlerCallback](https://elizaos.github.io/eliza/api/type-aliases/HandlerCallback/)
*   [Validator](https://elizaos.github.io/eliza/api/type-aliases/Validator/)
*   [Media](https://elizaos.github.io/eliza/api/type-aliases/Media/)
*   [Client](https://elizaos.github.io/eliza/api/type-aliases/Client/)
*   [Plugin](https://elizaos.github.io/eliza/api/type-aliases/Plugin/)
*   [TelemetrySettings](https://elizaos.github.io/eliza/api/type-aliases/TelemetrySettings/)
*   [Character](https://elizaos.github.io/eliza/api/type-aliases/Character/)
*   [CacheOptions](https://elizaos.github.io/eliza/api/type-aliases/CacheOptions/)
*   [SearchImage](https://elizaos.github.io/eliza/api/type-aliases/SearchImage/)
*   [SearchResult](https://elizaos.github.io/eliza/api/type-aliases/SearchResult/)
*   [SearchResponse](https://elizaos.github.io/eliza/api/type-aliases/SearchResponse/)
*   [KnowledgeItem](https://elizaos.github.io/eliza/api/type-aliases/KnowledgeItem/)

Variables[​](#variables "Direct link to Variables")
---------------------------------------------------

*   [defaultCharacter](https://elizaos.github.io/eliza/api/variables/defaultCharacter/)
*   [EmbeddingProvider](https://elizaos.github.io/eliza/api/variables/EmbeddingProvider/)
*   [envSchema](https://elizaos.github.io/eliza/api/variables/envSchema/)
*   [CharacterSchema](https://elizaos.github.io/eliza/api/variables/CharacterSchema/)
*   [evaluationTemplate](https://elizaos.github.io/eliza/api/variables/evaluationTemplate/)
*   [knowledge](https://elizaos.github.io/eliza/api/variables/knowledge/)
*   [elizaLogger](https://elizaos.github.io/eliza/api/variables/elizaLogger/)
*   [models](https://elizaos.github.io/eliza/api/variables/models/)
*   [messageCompletionFooter](https://elizaos.github.io/eliza/api/variables/messageCompletionFooter/)
*   [shouldRespondFooter](https://elizaos.github.io/eliza/api/variables/shouldRespondFooter/)
*   [booleanFooter](https://elizaos.github.io/eliza/api/variables/booleanFooter/)
*   [stringArrayFooter](https://elizaos.github.io/eliza/api/variables/stringArrayFooter/)
*   [postActionResponseFooter](https://elizaos.github.io/eliza/api/variables/postActionResponseFooter/)
*   [settings](https://elizaos.github.io/eliza/api/variables/settings/)

Functions[​](#functions "Direct link to Functions")
---------------------------------------------------

*   [composeActionExamples](https://elizaos.github.io/eliza/api/functions/composeActionExamples/)
*   [formatActionNames](https://elizaos.github.io/eliza/api/functions/formatActionNames/)
*   [formatActions](https://elizaos.github.io/eliza/api/functions/formatActions/)
*   [composeContext](https://elizaos.github.io/eliza/api/functions/composeContext/)
*   [addHeader](https://elizaos.github.io/eliza/api/functions/addHeader/)
*   [composeRandomUser](https://elizaos.github.io/eliza/api/functions/composeRandomUser/)
*   [getEmbeddingConfig](https://elizaos.github.io/eliza/api/functions/getEmbeddingConfig/)
*   [getEmbeddingType](https://elizaos.github.io/eliza/api/functions/getEmbeddingType/)
*   [getEmbeddingZeroVector](https://elizaos.github.io/eliza/api/functions/getEmbeddingZeroVector/)
*   [embed](https://elizaos.github.io/eliza/api/functions/embed/)
*   [validateEnv](https://elizaos.github.io/eliza/api/functions/validateEnv/)
*   [validateCharacterConfig](https://elizaos.github.io/eliza/api/functions/validateCharacterConfig/)
*   [formatEvaluatorNames](https://elizaos.github.io/eliza/api/functions/formatEvaluatorNames/)
*   [formatEvaluators](https://elizaos.github.io/eliza/api/functions/formatEvaluators/)
*   [formatEvaluatorExamples](https://elizaos.github.io/eliza/api/functions/formatEvaluatorExamples/)
*   [formatEvaluatorExampleDescriptions](https://elizaos.github.io/eliza/api/functions/formatEvaluatorExampleDescriptions/)
*   [generateText](https://elizaos.github.io/eliza/api/functions/generateText/)
*   [trimTokens](https://elizaos.github.io/eliza/api/functions/trimTokens/)
*   [generateShouldRespond](https://elizaos.github.io/eliza/api/functions/generateShouldRespond/)
*   [splitChunks](https://elizaos.github.io/eliza/api/functions/splitChunks/)
*   [generateTrueOrFalse](https://elizaos.github.io/eliza/api/functions/generateTrueOrFalse/)
*   [generateTextArray](https://elizaos.github.io/eliza/api/functions/generateTextArray/)
*   [generateObjectDeprecated](https://elizaos.github.io/eliza/api/functions/generateObjectDeprecated/)
*   [generateObjectArray](https://elizaos.github.io/eliza/api/functions/generateObjectArray/)
*   [generateMessageResponse](https://elizaos.github.io/eliza/api/functions/generateMessageResponse/)
*   [generateImage](https://elizaos.github.io/eliza/api/functions/generateImage/)
*   [generateCaption](https://elizaos.github.io/eliza/api/functions/generateCaption/)
*   [generateWebSearch](https://elizaos.github.io/eliza/api/functions/generateWebSearch/)
*   [generateObject](https://elizaos.github.io/eliza/api/functions/generateObject/)
*   [handleProvider](https://elizaos.github.io/eliza/api/functions/handleProvider/)
*   [generateTweetActions](https://elizaos.github.io/eliza/api/functions/generateTweetActions/)
*   [getGoals](https://elizaos.github.io/eliza/api/functions/getGoals/)
*   [formatGoalsAsString](https://elizaos.github.io/eliza/api/functions/formatGoalsAsString/)
*   [updateGoal](https://elizaos.github.io/eliza/api/functions/updateGoal/)
*   [createGoal](https://elizaos.github.io/eliza/api/functions/createGoal/)
*   [getActorDetails](https://elizaos.github.io/eliza/api/functions/getActorDetails/)
*   [formatActors](https://elizaos.github.io/eliza/api/functions/formatActors/)
*   [formatMessages](https://elizaos.github.io/eliza/api/functions/formatMessages/)
*   [formatTimestamp](https://elizaos.github.io/eliza/api/functions/formatTimestamp/)
*   [getModel](https://elizaos.github.io/eliza/api/functions/getModel/)
*   [getEndpoint](https://elizaos.github.io/eliza/api/functions/getEndpoint/)
*   [parseShouldRespondFromText](https://elizaos.github.io/eliza/api/functions/parseShouldRespondFromText/)
*   [parseBooleanFromText](https://elizaos.github.io/eliza/api/functions/parseBooleanFromText/)
*   [parseJsonArrayFromText](https://elizaos.github.io/eliza/api/functions/parseJsonArrayFromText/)
*   [parseJSONObjectFromText](https://elizaos.github.io/eliza/api/functions/parseJSONObjectFromText/)
*   [parseActionResponseFromText](https://elizaos.github.io/eliza/api/functions/parseActionResponseFromText/)
*   [formatPosts](https://elizaos.github.io/eliza/api/functions/formatPosts/)
*   [getProviders](https://elizaos.github.io/eliza/api/functions/getProviders/)
*   [createRelationship](https://elizaos.github.io/eliza/api/functions/createRelationship/)
*   [getRelationship](https://elizaos.github.io/eliza/api/functions/getRelationship/)
*   [getRelationships](https://elizaos.github.io/eliza/api/functions/getRelationships/)
*   [formatRelationships](https://elizaos.github.io/eliza/api/functions/formatRelationships/)
*   [findNearestEnvFile](https://elizaos.github.io/eliza/api/functions/findNearestEnvFile/)
*   [configureSettings](https://elizaos.github.io/eliza/api/functions/configureSettings/)
*   [loadEnvConfig](https://elizaos.github.io/eliza/api/functions/loadEnvConfig/)
*   [getEnvVariable](https://elizaos.github.io/eliza/api/functions/getEnvVariable/)
*   [hasEnvVariable](https://elizaos.github.io/eliza/api/functions/hasEnvVariable/)
*   [stringToUuid](https://elizaos.github.io/eliza/api/functions/stringToUuid/)

[

Previous

validateEnv

](https://elizaos.github.io/eliza/api/functions/validateEnv/)[

Next

Account

](https://elizaos.github.io/eliza/api/interfaces/Account/)

*   [Enumerations](#enumerations)
*   [Classes](#classes)
*   [Interfaces](#interfaces)
*   [Type Aliases](#type-aliases)
*   [Variables](#variables)
*   [Functions](#functions)</content>
</page>

<page>
  <title>Frequently Asked Questions | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/faq/</url>
  <content>Eliza FAQ[​](#eliza-faq "Direct link to Eliza FAQ")
---------------------------------------------------

### What is Eliza?[​](#what-is-eliza "Direct link to What is Eliza?")

**Eliza is an open-source, multi-agent simulation framework for creating and managing autonomous AI agents.** The project aims to empower developers and users to build unique AI personalities that can interact across various platforms, such as Discord, Twitter, and Telegram.

### Who is behind Eliza?[​](#who-is-behind-eliza "Direct link to Who is behind Eliza?")

The Eliza project is led by the developers of $ai16z, an AI-driven DAO. The project is open source, and its code is available on GitHub: [https://github.com/elizaos/eliza](https://github.com/elizaos/eliza)

### How can I get started with Eliza?[​](#how-can-i-get-started-with-eliza "Direct link to How can I get started with Eliza?")

To begin building your own AI agents with Eliza, follow these steps:

1.  **Install Python, Node.js and pnpm**: Ensure you have the necessary software prerequisites installed on your system. We use node v23.
2.  **Set up your environment**: Create a `.env` file and populate it with the required API keys, database configuration, and platform-specific tokens.
3.  **Install Eliza**: Use the command `npm install @elizaos/core` or `pnpm add @elizaos/core` to install the Eliza package.
4.  **Configure your database**: Eliza currently relies on Supabase for local development. Follow the instructions in the documentation to set up your Supabase project and database.
5.  **Define your agent's character**: Create a character file using the provided JSON format to specify your agent's personality, knowledge, and behavior.
6.  **Run Eliza locally**: Use the provided commands to start the Eliza framework and interact with your agent.

### What are the key components of Eliza?[​](#what-are-the-key-components-of-eliza "Direct link to What are the key components of Eliza?")

Eliza's architecture consists of several interconnected components:

*   **Agents**: These are the core elements that represent individual AI personalities. Agents operate within a runtime environment and interact with various platforms.
*   **Actions**: Actions are predefined behaviors that agents can execute in response to messages, enabling them to perform tasks and interact with external systems.
*   **Clients**: Clients act as interfaces between agents and specific platforms, such as Discord, Twitter, and Telegram. They handle platform-specific message formats and communication protocols.
*   **Plugins**: Plugins are modular way to extend the core functionality with additional features, actions, evaluators, and providers. They are self-contained modules that can be easily added or removed to customize your agent's capabilities
*   **Providers**: Providers supply agents with contextual information, including time awareness, user relationships, and data from external sources.
*   **Evaluators**: These modules assess and extract information from conversations, helping agents track goals, build memory, and maintain context awareness.
*   **Character Files**: These JSON files define the personality, knowledge, and behavior of each AI agent.
*   **Memory System**: Eliza features a sophisticated memory management system that utilizes vector embeddings and relational database storage to store and retrieve information for agents.

### How can I contribute to the Eliza project?[​](#how-can-i-contribute-to-the-eliza-project "Direct link to How can I contribute to the Eliza project?")

Eliza welcomes contributions from individuals with a wide range of skills:

#### Technical Contributions[​](#technical-contributions "Direct link to Technical Contributions")

*   **Develop new actions, clients, providers, and evaluators**: Extend Eliza's functionality by creating new modules or enhancing existing ones.
*   **Contribute to database management**: Improve or expand Eliza's database capabilities using PostgreSQL, SQLite, or SQL.js.
*   **Enhance local development workflows**: Improve documentation and tools for local development using SQLite and VS Code.
*   **Fine-tune models**: Optimize existing models or implement new models for specific tasks and personalities.
*   **Contribute to the autonomous trading system and trust engine**: Leverage expertise in market analysis, technical analysis, and risk management to enhance these features.

#### Non-Technical Contributions[​](#non-technical-contributions "Direct link to Non-Technical Contributions")

*   **Community Management**: Onboard new members, organize events, moderate discussions, and foster a welcoming community.
*   **Content Creation**: Create memes, tutorials, documentation, and videos to share project updates.
*   **Translation**: Translate documentation and other materials to make Eliza accessible to a global audience.
*   **Domain Expertise**: Provide insights and feedback on specific applications of Eliza in various fields.

### What are the future plans for Eliza?[​](#what-are-the-future-plans-for-eliza "Direct link to What are the future plans for Eliza?")

The Eliza project is continuously evolving, with ongoing development and community contributions. The team is actively working on:

*   **Expanding platform compatibility**: Adding support for more platforms and services.
*   **Improving model capabilities**: Enhance agent performance and capabilities with existing and new models.
*   **Enhancing the trust engine**: Provide robust and secure recommendations within decentralized networks.
*   **Fostering community growth**: Rewarding contributions to expand the project's reach and impact.

* * *

$ai16z FAQ[​](#ai16z-faq "Direct link to $ai16z FAQ")
-----------------------------------------------------

### What is $ai16z and how is it related to Eliza?[​](#what-is-ai16z-and-how-is-it-related-to-eliza "Direct link to What is $ai16z and how is it related to Eliza?")

**$ai16z is an AI-driven DAO and fund launched on daos.fun.** The developers of Eliza created $ai16z to support their work in autonomous AI agents. While $ai16z primarily focuses on trading, Eliza is a more general-purpose framework that can be used for various applications beyond finance.

### When will token is mintable be fixed?[​](#when-will-token-is-mintable-be-fixed "Direct link to When will token is mintable be fixed?")

Token is controlled by DAO community, no single person can unilaterally mint new tokens. The daos.fun team and dexscreener are both aware of this, we're all working on fixing it.

### Liquidity seems low[​](#liquidity-seems-low "Direct link to Liquidity seems low")

The DAOs.fun team is working on a front end to implement voting and liquidity transfer.

### What is the difference between $ai16z and $degenai?[​](#what-is-the-difference-between-ai16z-and-degenai "Direct link to What is the difference between $ai16z and $degenai?")

The $ai16z token is the governance token of the ai16z DAO. Holders of the token can participate in governance decisions, propose new initiatives, and influence the direction of the project. DegenSpartanAI is another trading agent project created by Shaw, which has different goals and trading strategies. $ai16z is envisioned as a community-driven, PvE (player versus environment) focused fund, while $degenai is more of a trading agent with a PvP (player versus player), aggressive approach.

### Will the agent launch pump fund coins?[​](#will-the-agent-launch-pump-fund-coins "Direct link to Will the agent launch pump fund coins?")

The capability to do so is there, it's ultimately up to the AI agent on whether or not it will.

### Can the agent invest in my project?[​](#can-the-agent-invest-in-my-project "Direct link to Can the agent invest in my project?")

Yes, if you make a convincing argument.

### Who runs $ai16z?[​](#who-runs-ai16z "Direct link to Who runs $ai16z?")

$ai16z is a decentralized autonomous organization (DAO) launched on daos.fun and led by AI agents. Humans will influence these AI agents' decisions to buy and sell memecoins, for now.

### What happens when people copy the GitHub?[​](#what-happens-when-people-copy-the-github "Direct link to What happens when people copy the GitHub?")

Many are already creating their own AI agents using the open-source ELIZA framework, but they won't have access to the pre-trained models used by $ai16z and degenai.

### What are the future plans for $ai16z?[​](#what-are-the-future-plans-for-ai16z "Direct link to What are the future plans for $ai16z?")

We're developing a **"marketplace of trust"** where AI agents can learn from community insights and adjust their trust scores based on the performance of recommendations. Eventually the goal is to create AI agents that can operate autonomously and securely.

### How can I contribute?[​](#how-can-i-contribute "Direct link to How can I contribute?")

There are several ways to contribute:

*   **Participate in community discussions**: Share your memecoin insights, propose new ideas, and engage with other community members.
*   **Contribute to the development of the elizaos platform**: [https://github.com/orgs/elizaos/projects/1/views/3](https://github.com/orgs/elizaos/projects/1/views/3)
*   **Help build the elizaos ecosystem**: Create applicatoins / tools, resources, and memes. Give feedback, and spread the word

**Other questions:**

*   $ai16z and a16z are not officially affiliated.
*   ELIZA is an open-source conversational agent framework.
*   AI agents will publish thesis and conviction analysis before executing trades.
*   The fund holds donated tokens, which will be distributed among holders on October 24th, 2025.</content>
</page>

<page>
  <title>🤖 Agents | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/core/agents/</url>
  <content>Agents are the core components of the Eliza framework that handle autonomous interactions. Each agent runs in a runtime environment and can interact through various clients (Discord, Telegram, etc.) while maintaining consistent behavior and memory.

* * *

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

The [AgentRuntime](https://elizaos.github.io/eliza/api/classes/AgentRuntime/) class is the primary implementation of the [IAgentRuntime](https://elizaos.github.io/eliza/api/interfaces/IAgentRuntime/) interface, which manages the agent's core functions, including:

*   **Message and Memory Processing**: Storing, retrieving, and managing conversation data and contextual memory.
*   **State Management**: Composing and updating the agent’s state for a coherent, ongoing interaction.
*   **Action Execution**: Handling behaviors such as transcribing media, generating images, and following rooms.
*   **Evaluation and Response**: Assessing responses, managing goals, and extracting relevant information.

* * *

Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

Each agent runtime consists of key components that enable flexible and extensible functionality:

1.  **Clients**: Enable communication across platforms such as Discord, Telegram, and Direct (REST API), with features tailored for each platform.
2.  **Providers**: Extend the agent’s capabilities by integrating with additional services (e.g., time, wallet, or custom data).
3.  **Actions**: Define agent behaviors, such as following rooms, generating images, or processing attachments. Custom actions can be created to tailor behaviors to specific needs.
4.  **Evaluators**: Manage agent responses by assessing message relevance, managing goals, extracting facts, and building long-term memory.

### AgentRuntime Interface[​](#agentruntime-interface "Direct link to AgentRuntime Interface")

The `IAgentRuntime` interface defines the main structure of the runtime environment, specifying the configuration and essential components:

    interface IAgentRuntime {    // Core identification    agentId: UUID;    serverUrl: string;    token: string;    // Configuration    character: Character;    modelProvider: ModelProviderName;    // Components    actions: Action[];    evaluators: Evaluator[];    providers: Provider[];    // Database & Memory    databaseAdapter: IDatabaseAdapter;    messageManager: IMemoryManager;    descriptionManager: IMemoryManager;    loreManager: IMemoryManager;}

Each element in the runtime interface plays a crucial role:

*   **Identification**: Agent ID, server URL, and token for authentication and identification.
*   **Configuration**: Character profile and model provider define the agent's personality and language model.
*   **Components**: Actions, evaluators, and providers support extensible behaviors, response evaluation, and service integration.
*   **Memory Management**: Specialized memory managers track conversations, descriptions, and static knowledge to enable contextual and adaptive responses.

* * *

Creating an Agent Runtime[​](#creating-an-agent-runtime "Direct link to Creating an Agent Runtime")
---------------------------------------------------------------------------------------------------

This section demonstrates setting up an agent with basic and optional configurations. It provides a working example and sample code that helps users quickly start building:

    import { AgentRuntime, ModelProviderName } from "@elizaos/core";// Configuration exampleconst runtime = new AgentRuntime({    token: "auth-token",    modelProvider: ModelProviderName.ANTHROPIC,    character: characterConfig,    databaseAdapter: new DatabaseAdapter(),    conversationLength: 32,    serverUrl: "http://localhost:7998",    actions: customActions,    evaluators: customEvaluators,    providers: customProviders,});

* * *

State Management[​](#state-management "Direct link to State Management")
------------------------------------------------------------------------

This section covers how agents manage and update state, with a focus on initial state composition and updating methods. The runtime maintains state through the [State](https://elizaos.github.io/eliza/api/interfaces/state/) interface:

    interface State {    userId?: UUID;    agentId?: UUID;    roomId: UUID;    bio: string;    lore: string;    agentName?: string;    senderName?: string;    actors: string;    actorsData?: Actor[];    recentMessages: string;    recentMessagesData: Memory[];    goals?: string;    goalsData?: Goal[];    actions?: string;    actionNames?: string;    providers?: string;}

State composition and updates are handled through dedicated methods:

    // Compose initial stateconst state = await runtime.composeState(message, {    additionalContext: "custom-context",});// Update message stateconst updatedState = await runtime.updateRecentMessageState(state);

**Best practices**

*   Keep state immutable where possible
*   Use `composeState` for initial state creation
*   Use `updateRecentMessageState` for updates
*   Cache frequently accessed state data

* * *

Memory Systems[​](#memory-systems "Direct link to Memory Systems")
------------------------------------------------------------------

The Eliza framework uses multiple types of memory to support an agent's long-term engagement, contextual understanding, and adaptive responses. Each type of memory serves a specific purpose:

*   **Message History**: Stores recent conversations to provide continuity within a session. This helps the agent maintain conversational context and avoid repetitive responses within short-term exchanges.
    
*   **Factual Memory**: Holds specific, context-based facts about the user or environment, such as user preferences, recent activities, or specific details mentioned in previous interactions. This type of memory enables the agent to recall user-specific information across sessions.
    
*   **Knowledge Base**: Contains general knowledge the agent might need to respond to broader queries or provide informative answers. This memory is more static, helping the agent retrieve pre-defined data, common responses, or static character lore.
    
*   **Relationship Tracking**: Manages the agent’s understanding of its relationship with users, including details like user-agent interaction frequency, sentiment, and connection history. It is particularly useful for building rapport and providing a more personalized interaction experience over time.
    
*   **RAG Integration**: Uses a vector search to perform contextual recall based on similarity matching. This enables the agent to retrieve relevant memory snippets or knowledge based on the content and intent of the current conversation, making its responses more contextually relevant.
    

The runtime uses multiple specialized [IMemoryManager](https://elizaos.github.io/eliza/api/interfaces/IMemoryManager/) instances:

*   `messageManager` - conversation messages and responses
*   `descriptionManager` - user descriptions and profiles
*   `loreManager` - static character knowledge

* * *

Message Processing[​](#message-processing "Direct link to Message Processing")
------------------------------------------------------------------------------

The runtime's message processing is handled through the [processActions](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#processactions) method:

    // Process message with actionsawait runtime.processActions(message, responses, state, async (newMessages) => {    // Handle new messages    return [message];});

* * *

Services and Memory Management[​](#services-and-memory-management "Direct link to Services and Memory Management")
------------------------------------------------------------------------------------------------------------------

Services are managed through the [getService](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#getservice) and [registerService](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#registerservice) methods:

    // Register serviceruntime.registerService(new TranscriptionService());// Get serviceconst service = runtime.getService<ITranscriptionService>(    ServiceType.TRANSCRIPTION,);

### Memory Management[​](#memory-management "Direct link to Memory Management")

Memory managers are accessed via [getMemoryManager](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#getmemorymanager):

    // Get memory managerconst memoryManager = runtime.getMemoryManager("messages");// Create memoryawait memoryManager.createMemory({    id: messageId,    content: { text: "Message content" },    userId: userId,    roomId: roomId,});

**Best practices**

*   Use appropriate memory managers for different data types
*   Consider memory limits when storing data, regularly clean up memory
*   Use the `unique` flag for deduplicated storage
*   Clean up old memories periodically
*   Use immutability in state management.
*   Log errors and maintain stability during service failures.

* * *

Evaluation System[​](#evaluation-system "Direct link to Evaluation System")
---------------------------------------------------------------------------

The runtime's [evaluate](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#evaluate) method processes evaluations:

    // Evaluate messageconst evaluationResults = await runtime.evaluate(message, state, didRespond);

* * *

Usage Examples[​](#usage-examples "Direct link to Usage Examples")
------------------------------------------------------------------

1.  **Message Processing**:

    await runtime.processActions(message, responses, state, (newMessages) => {    return [message];});

2.  **State Management**:

    const state = await runtime.composeState(message, {    additionalContext: "custom-context",});

3.  **Memory Management**:

    const memoryManager = runtime.getMemoryManager("messages");await memoryManager.createMemory({    id: messageId,    content: { text: "Message content" },    userId,    roomId,});

* * *

Further Reading[​](#further-reading "Direct link to Further Reading")
---------------------------------------------------------------------

*   [Actions Documentation](https://elizaos.github.io/eliza/docs/core/actions/)
*   [Evaluators Documentation](https://elizaos.github.io/eliza/docs/core/evaluators/)
*   [Providers Documentation](https://elizaos.github.io/eliza/docs/core/providers/)
*   [Full API Reference](https://elizaos.github.io/eliza/api/)</content>
</page>

<page>
  <title>📊 Evaluators | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/core/evaluators/</url>
  <content>[Evaluators](https://elizaos.github.io/eliza/api/interfaces/evaluator/) are core components that assess and extract information from conversations. They integrate with the [AgentRuntime](https://elizaos.github.io/eliza/api/classes/AgentRuntime/)'s evaluation system.

* * *

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

Evaluators enable agents to:

*   Build long-term memory
*   Track goal progress
*   Extract facts and insights
*   Maintain contextual awareness

* * *

Quick Start[​](#quick-start "Direct link to Quick Start")
---------------------------------------------------------

1.  Import the necessary evaluator types:

    import { Evaluator, IAgentRuntime, Memory, State } from "@elizaos/core-core";

2.  Choose or create an evaluator:

    const evaluator: Evaluator = {    name: "BASIC_EVALUATOR",    similes: ["SIMPLE_EVALUATOR"],    description: "Evaluates basic conversation elements",    validate: async (runtime: IAgentRuntime, message: Memory) => true,    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Evaluation logic here        return result;    },    examples: [],};

* * *

Built-in Evaluators[​](#built-in-evaluators "Direct link to Built-in Evaluators")
---------------------------------------------------------------------------------

### Fact Evaluator[​](#fact-evaluator "Direct link to Fact Evaluator")

The fact evaluator extracts and stores factual information from conversations.

    interface Fact {    claim: string;    type: "fact" | "opinion" | "status";    in_bio: boolean;    already_known: boolean;}

Source: [https://github.com/elizaos/eliza/blob/main/packages/core/src/types.ts](https://github.com/elizaos/eliza/blob/main/packages/core/src/types.ts)

**Example Facts:**

    {    "claim": "User completed marathon training",    "type": "fact",    "in_bio": false,    "already_known": false}

### Goal Evaluator[​](#goal-evaluator "Direct link to Goal Evaluator")

From bootstrap plugin - tracks conversation goals:

    interface Goal {    id: string;    name: string;    status: "IN_PROGRESS" | "DONE" | "FAILED";    objectives: Objective[];}interface Objective {    description: string;    completed: boolean;}

* * *

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

*   Validate facts before storage
*   Avoid duplicate entries
*   Include relevant context
*   Properly categorize information types

### Goal Tracking[​](#goal-tracking "Direct link to Goal Tracking")

*   Define clear, measurable objectives
*   Update only changed goals
*   Handle failures gracefully
*   Track partial progress

### Validation[​](#validation "Direct link to Validation")

*   Keep validation logic efficient
*   Check prerequisites first
*   Consider message content and state
*   Use appropriate memory managers

### Handler Implementation[​](#handler-implementation "Direct link to Handler Implementation")

*   Use runtime services appropriately
*   Store results in correct memory manager
*   Handle errors gracefully
*   Maintain state consistency

### Examples[​](#examples "Direct link to Examples")

*   Provide clear context descriptions
*   Show typical trigger messages
*   Document expected outcomes
*   Cover edge cases

* * *

Creating Custom Evaluators[​](#creating-custom-evaluators "Direct link to Creating Custom Evaluators")
------------------------------------------------------------------------------------------------------

Implement the Evaluator interface:

    interface Evaluator {    name: string;    similes: string[];    description: string;    validate: (runtime: IAgentRuntime, message: Memory) => Promise<boolean>;    handler: (        runtime: IAgentRuntime,        message: Memory,        state?: State,        options?: any,    ) => Promise<any>;    examples: EvaluatorExample[];}

Source: [https://github.com/elizaos/eliza/blob/main/packages/core/src/types.ts](https://github.com/elizaos/eliza/blob/main/packages/core/src/types.ts)

### Memory Integration[​](#memory-integration "Direct link to Memory Integration")

Example of storing evaluator results:

    try {    const memory = await runtime.memoryManager.addEmbeddingToMemory({        userId: user?.id,        content: { text: evaluationResult },        roomId: roomId,        embedding: await embed(runtime, evaluationResult),    });    await runtime.memoryManager.createMemory(memory);} catch (error) {    console.error("Failed to store evaluation result:", error);}

Source: [https://github.com/elizaos/eliza/blob/main/packages/core/src/tests/memory.test.ts](https://github.com/elizaos/eliza/blob/main/packages/core/src/tests/memory.test.ts)

### Memory Usage[​](#memory-usage "Direct link to Memory Usage")

Evaluators should use runtime memory managers for storage:

    const memoryEvaluator: Evaluator = {    name: "MEMORY_EVAL",    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Store in message memory        await runtime.messageManager.createMemory({            id: message.id,            content: message.content,            roomId: message.roomId,            userId: message.userId,            agentId: runtime.agentId,        });        // Store in description memory        await runtime.descriptionManager.createMemory({            id: message.id,            content: { text: "User description" },            roomId: message.roomId,            userId: message.userId,            agentId: runtime.agentId,        });    },};

* * *

Integration with Agent Runtime[​](#integration-with-agent-runtime "Direct link to Integration with Agent Runtime")
------------------------------------------------------------------------------------------------------------------

The [AgentRuntime](https://elizaos.github.io/eliza/api/classes/AgentRuntime/) processes evaluators through its [evaluate](https://elizaos.github.io/eliza/api/classes/AgentRuntime/#evaluate) method:

    // Register evaluatorruntime.registerEvaluator(customEvaluator);// Process evaluationsconst results = await runtime.evaluate(message, state);

* * *

Error Handling[​](#error-handling "Direct link to Error Handling")
------------------------------------------------------------------

    const robustEvaluator: Evaluator = {    name: "ROBUST_EVAL",    handler: async (runtime: IAgentRuntime, message: Memory) => {        try {            // Attempt evaluation            await runtime.messageManager.createMemory({                id: message.id,                content: message.content,                roomId: message.roomId,                userId: message.userId,                agentId: runtime.agentId,            });        } catch (error) {            // Log error and handle gracefully            console.error("Evaluation failed:", error);            // Store error state if needed            await runtime.messageManager.createMemory({                id: message.id,                content: { text: "Evaluation failed" },                roomId: message.roomId,                userId: message.userId,                agentId: runtime.agentId,            });        }    },};</content>
</page>

<page>
  <title>📝 Character Files | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/core/characterfile/</url>
  <content>Character files are JSON-formatted configurations that define an AI character's personality, knowledge, and behavior patterns. This guide explains how to create effective character files for use with Eliza agents.

* * *

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

A `characterfile` implements the [Character](https://elizaos.github.io/eliza/api/type-aliases/character/) type and defines the character's:

*   Core identity and behavior
*   Model provider configuration
*   Client settings and capabilities
*   Interaction examples and style guidelines

**Example:**

    {    "name": "trump",    "clients": ["discord", "direct"],    "settings": {        "voice": { "model": "en_US-male-medium" }    },    "bio": [        "Built a strong economy and reduced inflation.",        "Promises to make America the crypto capital and restore affordability."    ],    "lore": [        "Secret Service allocations used for election interference.",        "Promotes WorldLibertyFi for crypto leadership."    ],    "knowledge": [        "Understands border issues, Secret Service dynamics, and financial impacts on families."    ],    "messageExamples": [        {            "user": "{{user1}}",            "content": { "text": "What about the border crisis?" },            "response": "Current administration lets in violent criminals. I secured the border; they destroyed it."        }    ],    "postExamples": [        "End inflation and make America affordable again.",        "America needs law and order, not crime creation."    ]}

* * *

Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

    {    "id": "unique-identifier",    "name": "character_name",    "modelProvider": "ModelProviderName",    "clients": ["Client1", "Client2"],    "settings": {        "secrets": { "key": "value" },        "voice": { "model": "VoiceModelName", "url": "VoiceModelURL" },        "model": "CharacterModel",        "embeddingModel": "EmbeddingModelName"    },    "bio": "Character biography or description",    "lore": [        "Storyline or backstory element 1",        "Storyline or backstory element 2"    ],    "messageExamples": [["Message example 1", "Message example 2"]],    "postExamples": ["Post example 1", "Post example 2"],    "topics": ["Topic1", "Topic2"],    "adjectives": ["Adjective1", "Adjective2"],    "style": {        "all": ["All style guidelines"],        "chat": ["Chat-specific style guidelines"],        "post": ["Post-specific style guidelines"]    }}

### Key Fields[​](#key-fields "Direct link to Key Fields")

#### `name` (required)[​](#name-required "Direct link to name-required")

The character's display name for identification and in conversations.

#### `modelProvider` (required)[​](#modelprovider-required "Direct link to modelprovider-required")

Specifies the AI model provider. Supported options from [ModelProviderName](https://elizaos.github.io/eliza/api/enumerations/modelprovidername/) include `anthropic`, `llama_local`, `openai`, and others.

#### `clients` (required)[​](#clients-required "Direct link to clients-required")

Array of supported client types from [Clients](https://elizaos.github.io/eliza/api/enumerations/clients/) e.g., `discord`, `direct`, `twitter`, `telegram`, `farcaster`.

#### `bio`[​](#bio "Direct link to bio")

Character background as a string or array of statements.

*   Contains biographical information about the character
*   Can be a single comprehensive biography or multiple shorter statements
*   Multiple statements are randomized to create variety in responses

Example:

    "bio": [  "Mark Andreessen is an American entrepreneur and investor",  "Co-founder of Netscape and Andreessen Horowitz",  "Pioneer of the early web, created NCSA Mosaic"]

#### `lore`[​](#lore "Direct link to lore")

Backstory elements and unique character traits. These help define personality and can be randomly sampled in conversations.

Example:

    "lore": [  "Believes strongly in the power of software to transform industries",  "Known for saying 'Software is eating the world'",  "Early investor in Facebook, Twitter, and other tech giants"]

#### `knowledge`[​](#knowledge "Direct link to knowledge")

Array used for Retrieval Augmented Generation (RAG), containing facts or references to ground the character's responses.

*   Can contain chunks of text from articles, books, or other sources
*   Helps ground the character's responses in factual information
*   Knowledge can be generated from PDFs or other documents using provided tools

#### `messageExamples`[​](#messageexamples "Direct link to messageexamples")

Sample conversations for establishing interaction patterns, helps establish the character's conversational style.

    "messageExamples": [  [    {"user": "user1", "content": {"text": "What's your view on AI?"}},    {"user": "character", "content": {"text": "AI is transforming every industry..."}}  ]]

#### `postExamples`[​](#postexamples "Direct link to postexamples")

Sample social media posts to guide content style:

    "postExamples": [  "No tax on tips, overtime, or social security for seniors!",  "End inflation and make America affordable again."]

### Style Configuration[​](#style-configuration "Direct link to Style Configuration")

Contains three key sections:

1.  `all`: General style instructions for all interactions
2.  `chat`: Specific instructions for chat interactions
3.  `post`: Specific instructions for social media posts

Each section can contain multiple instructions that guide the character's communication style.

The `style` object defines behavior patterns across contexts:

    "style": {  "all": ["maintain technical accuracy", "be approachable and clear"],  "chat": ["ask clarifying questions", "provide examples when helpful"],  "post": ["share insights concisely", "focus on practical applications"]}

### Topics Array[​](#topics-array "Direct link to Topics Array")

*   List of subjects the character is interested in or knowledgeable about
*   Used to guide conversations and generate relevant content
*   Helps maintain character consistency

### Adjectives Array[​](#adjectives-array "Direct link to Adjectives Array")

*   Words that describe the character's traits and personality
*   Used for generating responses with consistent tone
*   Can be used in "Mad Libs" style content generation

### Settings Configuration[​](#settings-configuration "Direct link to Settings Configuration")

The `settings` object defines additional configurations like secrets and voice models.

    "settings": {  "secrets": { "API_KEY": "your-api-key" },  "voice": { "model": "voice-model-id", "url": "voice-service-url" },  "model": "specific-model-name",  "embeddingModel": "embedding-model-name"}

### Templates Configuration[​](#templates-configuration "Direct link to Templates Configuration")

The `templates` object defines customizable prompt templates used for various tasks and interactions. Below is the list of available templates:

*   `goalsTemplate`
*   `factsTemplate`
*   `messageHandlerTemplate`
*   `shouldRespondTemplate`
*   `continueMessageHandlerTemplate`
*   `evaluationTemplate`
*   `twitterSearchTemplate`
*   `twitterPostTemplate`
*   `twitterMessageHandlerTemplate`
*   `twitterShouldRespondTemplate`
*   `telegramMessageHandlerTemplate`
*   `telegramShouldRespondTemplate`
*   `discordVoiceHandlerTemplate`
*   `discordShouldRespondTemplate`
*   `discordMessageHandlerTemplate`

### Example: Twitter Post Template[​](#example-twitter-post-template "Direct link to Example: Twitter Post Template")

Here’s an example of a `twitterPostTemplate`:

    templates: {    twitterPostTemplate: `# Areas of Expertise{{knowledge}}# About {{agentName}} (@{{twitterUserName}}):{{bio}}{{lore}}{{topics}}{{providers}}{{characterPostExamples}}{{postDirections}}# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.Write a 1-3 sentence post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\n\\n (double spaces) between statements.`,}

* * *

Example: Complete Character File[​](#example-complete-character-file "Direct link to Example: Complete Character File")
-----------------------------------------------------------------------------------------------------------------------

    {    "name": "TechAI",    "modelProvider": "anthropic",    "clients": ["discord", "direct"],    "bio": "AI researcher and educator focused on practical applications",    "lore": [        "Pioneer in open-source AI development",        "Advocate for AI accessibility"    ],    "messageExamples": [        [            {                "user": "{{user1}}",                "content": { "text": "Can you explain how AI models work?" }            },            {                "user": "TechAI",                "content": {                    "text": "Think of AI models like pattern recognition systems."                }            }        ]    ],    "postExamples": [        "Understanding AI doesn't require a PhD - let's break it down simply",        "The best AI solutions focus on real human needs"    ],    "topics": [        "artificial intelligence",        "machine learning",        "technology education"    ],    "style": {        "all": [            "explain complex topics simply",            "be encouraging and supportive"        ],        "chat": ["use relevant examples", "check understanding"],        "post": ["focus on practical insights", "encourage learning"]    },    "adjectives": ["knowledgeable", "approachable", "practical"],    "settings": {        "model": "claude-3-opus-20240229",        "voice": { "model": "en-US-neural" }    }}

* * *

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

1.  **Randomization for Variety**

*   Break bio and lore into smaller chunks
*   This creates more natural, varied responses
*   Prevents repetitive or predictable behavior

2.  **Knowledge Management**

Use the provided tools to convert documents into knowledge:

*   [folder2knowledge](https://github.com/elizaos/characterfile/blob/main/scripts/folder2knowledge.js)
*   [knowledge2character](https://github.com/elizaos/characterfile/blob/main/scripts/knowledge2character.js)
*   [tweets2character](https://github.com/elizaos/characterfile/blob/main/scripts/tweets2character.js)

Example:

    npx folder2knowledge <path/to/folder>npx knowledge2character <character-file> <knowledge-file>

3.  **Style Instructions**

*   Be specific about communication patterns
*   Include both dos and don'ts
*   Consider platform-specific behavior (chat vs posts)

4.  **Message Examples**

*   Include diverse scenarios
*   Show character-specific responses
*   Demonstrate typical interaction patterns

* * *

Tips for Quality[​](#tips-for-quality "Direct link to Tips for Quality")
------------------------------------------------------------------------

1.  **Bio and Lore**

*   Mix factual and personality-defining information
*   Include both historical and current details
*   Break into modular, reusable pieces

2.  **Style Instructions**

*   Be specific about tone and mannerisms
*   Include platform-specific guidance
*   Define clear boundaries and limitations

3.  **Examples**

*   Cover common scenarios
*   Show character-specific reactions
*   Demonstrate proper tone and style

4.  **Knowledge**

*   Focus on relevant information
*   Organize in digestible chunks
*   Update regularly to maintain relevance

* * *

Further Reading[​](#further-reading "Direct link to Further Reading")
---------------------------------------------------------------------

*   [Agents Documentation](https://elizaos.github.io/eliza/docs/core/agents/)
*   [Model Providers](https://elizaos.github.io/eliza/docs/advanced/fine-tuning/)
*   [Client Integration](https://elizaos.github.io/eliza/docs/packages/clients/)</content>
</page>

<page>
  <title>Quickstart Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/quickstart/</url>
  <content>Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

Before getting started with Eliza, ensure you have:

*   [Node.js 23+](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
*   [pnpm 9+](https://pnpm.io/installation)
*   Git for version control
*   A code editor ([VS Code](https://code.visualstudio.com/) or [VSCodium](https://vscodium.com/) recommended)
*   [CUDA Toolkit](https://developer.nvidia.com/cuda-toolkit) (optional, for GPU acceleration)

Installation[​](#installation "Direct link to Installation")
------------------------------------------------------------

1.  **Clone and Install**
    
    Please be sure to check what the [latest available stable version tag](https://github.com/elizaos/eliza/tags) is.
    
    Clone the repository
    
        git clone https://github.com/elizaos/eliza.git
    
    Enter directory
    
    Switch to latest tagged release
    
         # Checkout the latest release # This project iterates fast, so we recommend checking out the latest release git checkout $(git describe --tags --abbrev=0)
    
    Install dependencies (on initial run)
    
        pnpm install --no-frozen-lockfile
    
    Quickstart Guide Update
    -----------------------
    

**Important Note on pnpm Lockfile Management**

By default, the `pnpm` lockfile will not be updated during installations based off of .npmrc frozen-lockfile=true. To update the lockfile, you need to run the command:

    pnpm install --no-frozen-lockfile

Please only use this command when you initially instantiating the repo or are bumping the version of a package or adding a new package to your package.json. This practice helps maintain consistency in your project's dependencies and prevents unintended changes to the lockfile.

Build the local libraries

2.  **Configure Environment**
    
    Copy example environment file
    
    Edit `.env` and add your values:
    
        # Suggested quickstart environment variablesDISCORD_APPLICATION_ID=  # For Discord integrationDISCORD_API_TOKEN=      # Bot tokenHEURIST_API_KEY=       # Heurist API key for LLM and image generationOPENAI_API_KEY=        # OpenAI API keyGROK_API_KEY=          # Grok API keyELEVENLABS_XI_API_KEY= # API key from elevenlabs (for voice)LIVEPEER_GATEWAY_URL=  # Livepeer gateway URL
    

Choose Your Model[​](#choose-your-model "Direct link to Choose Your Model")
---------------------------------------------------------------------------

Eliza supports multiple AI models:

*   **Heurist**: Set `modelProvider: "heurist"` in your character file. Most models are uncensored.
    *   LLM: Select available LLMs [here](https://docs.heurist.ai/dev-guide/supported-models#large-language-models-llms) and configure `SMALL_HEURIST_MODEL`,`MEDIUM_HEURIST_MODEL`,`LARGE_HEURIST_MODEL`
    *   Image Generation: Select available Stable Diffusion or Flux models [here](https://docs.heurist.ai/dev-guide/supported-models#image-generation-models) and configure `HEURIST_IMAGE_MODEL` (default is FLUX.1-dev)
*   **Llama**: Set `XAI_MODEL=meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo`
*   **Grok**: Set `XAI_MODEL=grok-beta`
*   **OpenAI**: Set `XAI_MODEL=gpt-4o-mini` or `gpt-4o`
*   **Livepeer**: Set `LIVEPEER_IMAGE_MODEL` to your chosen Livepeer image model, available models [here](https://livepeer-eliza.com/)

You set which model to use inside the character JSON file

### Local inference[​](#local-inference "Direct link to Local inference")

#### For llama\_local inference:[​](#for-llama_local-inference "Direct link to For llama_local inference:")

1.  Set `XAI_MODEL` to your chosen model
2.  Leave `X_SERVER_URL` and `XAI_API_KEY` blank
3.  The system will automatically download the model from Hugging Face
4.  `LOCAL_LLAMA_PROVIDER` can be blank

Note: llama\_local requires a GPU, it currently will not work with CPU inference

#### For Ollama inference:[​](#for-ollama-inference "Direct link to For Ollama inference:")

*   If `OLLAMA_SERVER_URL` is left blank, it defaults to `localhost:11434`
*   If `OLLAMA_EMBEDDING_MODE` is left blank, it defaults to `mxbai-embed-large`

Create Your First Agent[​](#create-your-first-agent "Direct link to Create Your First Agent")
---------------------------------------------------------------------------------------------

1.  **Create a Character File**
    
    Check out `characters/trump.character.json` or `characters/tate.character.json` as a template you can use to copy and customize your agent's personality and behavior. Additionally you can read `core/src/core/defaultCharacter.ts` (in 0.0.10 but post-refactor will be in `packages/core/src/defaultCharacter.ts`)
    
    📝 [Character Documentation](https://elizaos.github.io/eliza/docs/core/characterfile/)
    
2.  **Start the Agent**
    
    Inform it which character you want to run:
    
        pnpm start --character="characters/trump.character.json"
    
    You can also load multiple characters with the characters option with a comma separated list:
    
        pnpm start --characters="characters/trump.character.json,characters/tate.character.json"
    
3.  **Interact with the Agent**
    
    Now you're ready to start a conversation with your agent! Open a new terminal window
    
    Once the client is running, you'll see a message like this:
    

    ➜  Local:   http://localhost:5173/

Simply click the link or open your browser to `http://localhost:5173/`. You'll see the chat interface connect to the system, and you can begin interacting with your character.

Platform Integration[​](#platform-integration "Direct link to Platform Integration")
------------------------------------------------------------------------------------

### Discord Bot Setup[​](#discord-bot-setup "Direct link to Discord Bot Setup")

1.  Create a new application at [Discord Developer Portal](https://discord.com/developers/applications)
2.  Create a bot and get your token
3.  Add bot to your server using OAuth2 URL generator
4.  Set `DISCORD_API_TOKEN` and `DISCORD_APPLICATION_ID` in your `.env`

### Twitter Integration[​](#twitter-integration "Direct link to Twitter Integration")

Add to your `.env`:

    TWITTER_USERNAME=  # Account usernameTWITTER_PASSWORD=  # Account passwordTWITTER_EMAIL=    # Account email

**Important:** Log in to the [Twitter Developer Portal](https://developer.twitter.com/) and enable the "Automated" label for your account to avoid being flagged as inauthentic.

### Telegram Bot[​](#telegram-bot "Direct link to Telegram Bot")

1.  Create a bot
2.  Add your bot token to `.env`:

    TELEGRAM_BOT_TOKEN=your_token_here

Optional: GPU Acceleration[​](#optional-gpu-acceleration "Direct link to Optional: GPU Acceleration")
-----------------------------------------------------------------------------------------------------

If you have an NVIDIA GPU:

    # Install CUDA supportnpx --no node-llama-cpp source download --gpu cuda# Ensure CUDA Toolkit, cuDNN, and cuBLAS are installed

Basic Usage Examples[​](#basic-usage-examples "Direct link to Basic Usage Examples")
------------------------------------------------------------------------------------

### Chat with Your Agent[​](#chat-with-your-agent "Direct link to Chat with Your Agent")

    # Start chat interfacepnpm start

### Run Multiple Agents[​](#run-multiple-agents "Direct link to Run Multiple Agents")

    pnpm start --characters="characters/trump.character.json,characters/tate.character.json"

Common Issues & Solutions[​](#common-issues--solutions "Direct link to Common Issues & Solutions")
--------------------------------------------------------------------------------------------------

1.  **Node.js Version**
    
    *   Ensure Node.js 23.3.0 is installed
    *   Use `node -v` to check version
    *   Consider using [nvm](https://github.com/nvm-sh/nvm) to manage Node versions
    
    NOTE: pnpm may be bundled with a different node version, ignoring nvm. If this is the case, you can use
    
        pnpm env use --global 23.3.0
    
    to force it to use the correct one.
    
2.  **Sharp Installation** If you see Sharp-related errors:
    
        pnpm install --include=optional sharp
    
3.  **CUDA Setup**
    
    *   Verify CUDA Toolkit installation
    *   Check GPU compatibility with toolkit
    *   Ensure proper environment variables are set
4.  **Exit Status 1** If you see
    
        triggerUncaughtException(^[Object: null prototype] {[Symbol(nodejs.util.inspect.custom)]: [Function: [nodejs.util.inspect.custom]]}
    
    You can try these steps, which aim to add `@types/node` to various parts of the project
    
        # Add dependencies to workspace rootpnpm add -w -D ts-node typescript @types/node# Add dependencies to the agent package specificallypnpm add -D ts-node typescript @types/node --filter "@elizaos/agent"# Also add to the core package since it's needed there toopnpm add -D ts-node typescript @types/node --filter "@elizaos/core"# First clean everythingpnpm clean# Install all dependencies recursivelypnpm install -r# Build the projectpnpm build# Then try to startpnpm start
    
5.  **Better sqlite3 was compiled against a different Node.js version** If you see
    
        Error starting agents: Error: The module '.../eliza-agents/dv/eliza/node_modules/better-sqlite3/build/Release/better_sqlite3.node'was compiled against a different Node.js version usingNODE_MODULE_VERSION 131. This version of Node.js requiresNODE_MODULE_VERSION 127. Please try re-compiling or re-installing
    
    You can try this, which will attempt to rebuild better-sqlite3.
    
        pnpm rebuild better-sqlite3
    
    If that doesn't work, try clearing your node\_modules in the root folder
    
        rm -fr node_modules; pnpm store prune
    
    Then reinstall the requirements
    

Next Steps[​](#next-steps "Direct link to Next Steps")
------------------------------------------------------

Once you have your agent running, explore:

1.  🤖 [Understand Agents](https://elizaos.github.io/eliza/docs/core/agents/)
2.  📝 [Create Custom Characters](https://elizaos.github.io/eliza/docs/core/characterfile/)
3.  ⚡ [Add Custom Actions](https://elizaos.github.io/eliza/docs/core/actions/)
4.  🔧 [Advanced Configuration](https://elizaos.github.io/eliza/docs/guides/configuration/)

For detailed API documentation, troubleshooting, and advanced features, check out our [full documentation](https://elizaos.github.io/eliza/).

Join our [Discord community](https://discord.gg/ai16z) for support and updates!</content>
</page>

<page>
  <title>eliza | eliza</title>
  <url>https://elizaos.github.io/eliza/</url>
  <content>eliza is a simple, fast, and framework
--------------------------------------

Flexible, scalable AI agents for everyone

    npm install @elizaos/core

🤖

### Multi-Agent Framework

Build and deploy **autonomous AI agents** with consistent personalities across Discord, Twitter, and Telegram. Full support for voice, text, and media interactions.

🧠

### Advanced Capabilities

Built-in RAG memory system, document processing, media analysis, and autonomous trading capabilities. Supports multiple AI models including Llama, GPT-4, and Claude.

🔌

### Extensible Design

Create custom actions, add new platform integrations, and extend functionality through a **modular plugin system**. Full TypeScript support.</content>
</page>

<page>
  <title>⚡ Actions | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/core/actions/</url>
  <content>Actions are core building blocks in Eliza that define how agents respond to and interact with messages. They allow agents to interact with external systems, modify their behavior, and perform tasks beyond simple message responses.

* * *

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

Each Action consists of:

*   `name`: Unique identifier for the action
*   `similes`: Array of alternative names/variations
*   `description`: Detailed explanation of the action's purpose
*   `validate`: Function that checks if action is appropriate
*   `handler`: Implementation of the action's behavior
*   `examples`: Array of example usage patterns

* * *

Implementation[​](#implementation "Direct link to Implementation")
------------------------------------------------------------------

    interface Action {    name: string;    similes: string[];    description: string;    examples: ActionExample[][];    handler: Handler;    validate: Validator;    suppressInitialMessage?: boolean;}

Source: [https://github.com/elizaos/eliza/packages/core/src/types.ts](https://github.com/elizaos/eliza/packages/core/src/types.ts)

* * *

Built-in Actions
----------------

* * *

Conversation Flow[​](#conversation-flow "Direct link to Conversation Flow")
---------------------------------------------------------------------------

### CONTINUE[​](#continue "Direct link to CONTINUE")

*   Maintains conversation when more context is needed
*   Manages natural dialogue progression
*   Limited to 3 consecutive continues

### IGNORE[​](#ignore "Direct link to IGNORE")

*   Gracefully disengages from conversations
*   Handles:
    *   Inappropriate interactions
    *   Natural conversation endings
    *   Post-closing responses

### NONE[​](#none "Direct link to NONE")

*   Default response action
*   Used for standard conversational replies

* * *

External Integrations[​](#external-integrations "Direct link to External Integrations")
---------------------------------------------------------------------------------------

### TAKE\_ORDER[​](#take_order "Direct link to TAKE_ORDER")

*   Records trading/purchase orders
*   Processes user conviction levels
*   Validates ticker symbols and contract addresses

    const take_order: Action = {    name: "TAKE_ORDER",    similes: ["BUY_ORDER", "PLACE_ORDER"],    description: "Records a buy order based on the user's conviction level.",    validate: async (runtime: IAgentRuntime, message: Memory) => {        const text = (message.content as Content).text;        const tickerRegex = /\b[A-Z]{1,5}\b/g;        return tickerRegex.test(text);    },    // ... rest of implementation};

Source: [https://github.com/elizaos/eliza/packages/plugin-solana/src/actions/takeOrder.ts](https://github.com/elizaos/eliza/packages/plugin-solana/src/actions/takeOrder.ts)

* * *

Creating Custom Actions[​](#creating-custom-actions "Direct link to Creating Custom Actions")
---------------------------------------------------------------------------------------------

1.  Implement the Action interface
2.  Define validation logic
3.  Implement handler functionality
4.  Provide usage examples

Example:

    const customAction: Action = {    name: "CUSTOM_ACTION",    similes: ["SIMILAR_ACTION"],    description: "Action purpose",    validate: async (runtime: IAgentRuntime, message: Memory) => {        // Validation logic        return true;    },    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Implementation    },    examples: [],};

### Testing Actions[​](#testing-actions "Direct link to Testing Actions")

Use the built-in testing framework:

    test("Validate action behavior", async () => {    const message: Memory = {        userId: user.id,        content: { text: "Test message" },        roomId,    };    const response = await handleMessage(runtime, message);    // Verify response});

* * *

Core Concepts[​](#core-concepts "Direct link to Core Concepts")
---------------------------------------------------------------

### Action Structure[​](#action-structure "Direct link to Action Structure")

    interface Action {    name: string;    similes: string[];    description: string;    validate: (runtime: IAgentRuntime, message: Memory) => Promise<boolean>;    handler: (        runtime: IAgentRuntime,        message: Memory,        state?: State,    ) => Promise<void>;    examples: ActionExample[][];    suppressInitialMessage?: boolean;}

### Key Components[​](#key-components "Direct link to Key Components")

*   **name**: Unique identifier for the action
*   **similes**: Alternative names/triggers for the action
*   **description**: Explains when and how the action should be used
*   **validate**: Determines if the action can be executed
*   **handler**: Implements the action's behavior
*   **examples**: Demonstrates proper usage patterns
*   **suppressInitialMessage**: When true, suppresses the initial response message before processing the action. Useful for actions that generate their own responses (like image generation)

* * *

Built-in Actions[​](#built-in-actions-1 "Direct link to Built-in Actions")
--------------------------------------------------------------------------

### CONTINUE[​](#continue-1 "Direct link to CONTINUE")

Continues the conversation when appropriate:

    const continueAction: Action = {    name: "CONTINUE",    similes: ["ELABORATE", "KEEP_TALKING"],    description:        "Used when the message requires a follow-up. Don't use when conversation is finished.",    validate: async (runtime, message) => {        // Validation logic        return true;    },    handler: async (runtime, message, state) => {        // Continuation logic    },};

### IGNORE[​](#ignore-1 "Direct link to IGNORE")

Stops responding to irrelevant or completed conversations:

    const ignoreAction: Action = {    name: "IGNORE",    similes: ["STOP_TALKING", "STOP_CHATTING"],    description:        "Used when ignoring the user is appropriate (conversation ended, user is aggressive, etc.)",    handler: async (runtime, message) => {        return true;    },};

### FOLLOW\_ROOM[​](#follow_room "Direct link to FOLLOW_ROOM")

Actively participates in a conversation:

    const followRoomAction: Action = {    name: "FOLLOW_ROOM",    similes: ["FOLLOW_CHAT", "FOLLOW_CONVERSATION"],    description:        "Start following channel with interest, responding without explicit mentions.",    handler: async (runtime, message) => {        // Room following logic    },};

* * *

Creating Custom Actions[​](#creating-custom-actions-1 "Direct link to Creating Custom Actions")
-----------------------------------------------------------------------------------------------

### Basic Action Template[​](#basic-action-template "Direct link to Basic Action Template")

    const customAction: Action = {    name: "CUSTOM_ACTION",    similes: ["ALTERNATE_NAME", "OTHER_TRIGGER"],    description: "Detailed description of when and how to use this action",    validate: async (runtime: IAgentRuntime, message: Memory) => {        // Validation logic        return true;    },    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Implementation logic        return true;    },    examples: [        [            {                user: "{{user1}}",                content: { text: "Trigger message" },            },            {                user: "{{user2}}",                content: { text: "Response", action: "CUSTOM_ACTION" },            },        ],    ],};

### Advanced Action Example[​](#advanced-action-example "Direct link to Advanced Action Example")

    const complexAction: Action = {    name: "PROCESS_DOCUMENT",    similes: ["READ_DOCUMENT", "ANALYZE_DOCUMENT"],    description: "Process and analyze uploaded documents",    validate: async (runtime, message) => {        const hasAttachment = message.content.attachments?.length > 0;        const supportedTypes = ["pdf", "txt", "doc"];        return (            hasAttachment &&            supportedTypes.includes(message.content.attachments[0].type)        );    },    handler: async (runtime, message, state) => {        const attachment = message.content.attachments[0];        // Process document        const content = await runtime            .getService<IDocumentService>(ServiceType.DOCUMENT)            .processDocument(attachment);        // Store in memory        await runtime.documentsManager.createMemory({            id: generateId(),            content: { text: content },            userId: message.userId,            roomId: message.roomId,        });        return true;    },};

* * *

Implementation Patterns[​](#implementation-patterns "Direct link to Implementation Patterns")
---------------------------------------------------------------------------------------------

### State-Based Actions[​](#state-based-actions "Direct link to State-Based Actions")

    const stateAction: Action = {    name: "UPDATE_STATE",    handler: async (runtime, message, state) => {        const newState = await runtime.composeState(message, {            additionalData: "new-data",        });        await runtime.updateState(newState);        return true;    },};

### Service Integration[​](#service-integration "Direct link to Service Integration")

    const serviceAction: Action = {    name: "TRANSCRIBE_AUDIO",    handler: async (runtime, message) => {        const transcriptionService = runtime.getService<ITranscriptionService>(            ServiceType.TRANSCRIPTION,        );        const result = await transcriptionService.transcribe(            message.content.attachments[0],        );        return true;    },};

* * *

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### Action Design[​](#action-design "Direct link to Action Design")

1.  **Clear Purpose**
    
    *   Single responsibility principle
    *   Well-defined triggers
    *   Clear success criteria
2.  **Robust Validation**
    
    *   Check prerequisites
    *   Validate input data
    *   Handle edge cases
3.  **Error Handling**
    
    *   Graceful failure
    *   Meaningful error messages
    *   State recovery

### Example Organization[​](#example-organization "Direct link to Example Organization")

1.  **Comprehensive Coverage**

    examples: [    // Happy path    [basicUsageExample],    // Edge cases    [edgeCaseExample],    // Error cases    [errorCaseExample],];

2.  **Clear Context**

    examples: [    [        {            user: "{{user1}}",            content: {                text: "Context message showing why action is needed",            },        },        {            user: "{{user2}}",            content: {                text: "Clear response demonstrating action usage",                action: "ACTION_NAME",            },        },    ],];

* * *

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  **Action Not Triggering**
    
    *   Check validation logic
    *   Verify similes list
    *   Review example patterns
2.  **Handler Failures**
    
    *   Validate service availability
    *   Check state requirements
    *   Review error logs
3.  **State Inconsistencies**
    
    *   Verify state updates
    *   Check concurrent modifications
    *   Review state transitions

Advanced Features[​](#advanced-features "Direct link to Advanced Features")
---------------------------------------------------------------------------

### Action Composition[​](#action-composition "Direct link to Action Composition")

    const compositeAction: Action = {    name: "PROCESS_AND_RESPOND",    handler: async (runtime, message) => {        // Process first action        await runtime.processAction("ANALYZE_CONTENT", message);        // Process second action        await runtime.processAction("GENERATE_RESPONSE", message);        return true;    },};

### Action Chains[​](#action-chains "Direct link to Action Chains")

    const chainedAction: Action = {    name: "WORKFLOW",    handler: async (runtime, message) => {        const actions = ["VALIDATE", "PROCESS", "RESPOND"];        for (const actionName of actions) {            await runtime.processAction(actionName, message);        }        return true;    },};

* * *

Example: Complete Action Implementation[​](#example-complete-action-implementation "Direct link to Example: Complete Action Implementation")
--------------------------------------------------------------------------------------------------------------------------------------------

    import { Action, IAgentRuntime, Memory, State } from "@elizaos/core";const documentAnalysisAction: Action = {    name: "ANALYZE_DOCUMENT",    similes: ["READ_DOCUMENT", "PROCESS_DOCUMENT", "REVIEW_DOCUMENT"],    description: "Analyzes uploaded documents and provides insights",    validate: async (runtime: IAgentRuntime, message: Memory) => {        // Check for document attachment        if (!message.content.attachments?.length) {            return false;        }        // Verify document type        const attachment = message.content.attachments[0];        return ["pdf", "txt", "doc"].includes(attachment.type);    },    handler: async (runtime: IAgentRuntime, message: Memory, state?: State) => {        try {            // Get document service            const docService = runtime.getService<IDocumentService>(                ServiceType.DOCUMENT,            );            // Process document            const content = await docService.processDocument(                message.content.attachments[0],            );            // Store analysis            await runtime.documentsManager.createMemory({                id: generateId(),                content: {                    text: content,                    analysis: await docService.analyze(content),                },                userId: message.userId,                roomId: message.roomId,                createdAt: Date.now(),            });            return true;        } catch (error) {            console.error("Document analysis failed:", error);            return false;        }    },    examples: [        [            {                user: "{{user1}}",                content: {                    text: "Can you analyze this document?",                    attachments: [{ type: "pdf", url: "document.pdf" }],                },            },            {                user: "{{user2}}",                content: {                    text: "I'll analyze that document for you",                    action: "ANALYZE_DOCUMENT",                },            },        ],    ],};

* * *

Best Practices
--------------

1.  **Validation**
    
    *   Thoroughly check input parameters
    *   Verify runtime conditions
    *   Handle edge cases
2.  **Error Handling**
    
    *   Implement comprehensive error catching
    *   Provide clear error messages
    *   Clean up resources properly
3.  **Documentation**
    
    *   Include clear usage examples
    *   Document expected inputs/outputs
    *   Explain error scenarios

* * *

Further Reading[​](#further-reading "Direct link to Further Reading")
---------------------------------------------------------------------

*   [Provider System](https://elizaos.github.io/eliza/docs/core/providers/)
*   [Service Integration](#)
*   [Memory Management](https://elizaos.github.io/eliza/docs/packages/core/)</content>
</page>

<page>
  <title>⚙️ Configuration Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/guides/configuration/</url>
  <content>This guide covers how to configure Eliza for different use cases and environments. We'll walk through all available configuration options and best practices.

Environment Configuration[​](#environment-configuration "Direct link to Environment Configuration")
---------------------------------------------------------------------------------------------------

### Basic Setup[​](#basic-setup "Direct link to Basic Setup")

The first step is creating your environment configuration file:

### Core Environment Variables[​](#core-environment-variables "Direct link to Core Environment Variables")

Here are the essential environment variables you need to configure:

    # Core API KeysOPENAI_API_KEY=sk-your-key # Required for OpenAI featuresANTHROPIC_API_KEY=your-key  # Required for Claude modelsTOGETHER_API_KEY=your-key   # Required for Together.ai models# Default SettingsXAI_MODEL=gpt-4o-mini      # Default model to useX_SERVER_URL=              # Optional model API endpoint

### Client-Specific Configuration[​](#client-specific-configuration "Direct link to Client-Specific Configuration")

#### Discord Configuration[​](#discord-configuration "Direct link to Discord Configuration")

    DISCORD_APPLICATION_ID=     # Your Discord app IDDISCORD_API_TOKEN=         # Discord bot token

#### Twitter Configuration[​](#twitter-configuration "Direct link to Twitter Configuration")

    TWITTER_USERNAME=          # Bot Twitter usernameTWITTER_PASSWORD=          # Bot Twitter passwordTWITTER_EMAIL=            # Twitter account emailTWITTER_DRY_RUN=false    # Test mode without posting

#### Telegram Configuration[​](#telegram-configuration "Direct link to Telegram Configuration")

    TELEGRAM_BOT_TOKEN=       # Telegram bot token

### Model Provider Settings[​](#model-provider-settings "Direct link to Model Provider Settings")

You can configure different AI model providers:

    # OpenAI SettingsOPENAI_API_KEY=sk-*# Anthropic SettingsANTHROPIC_API_KEY=# Together.ai SettingsTOGETHER_API_KEY=# Heurist SettingsHEURIST_API_KEY=# Livepeer SettingsLIVEPEER_GATEWAY_URL=# Local Model SettingsXAI_MODEL=meta-llama/Llama-3.1-7b-instruct

### Image Generation[​](#image-generation "Direct link to Image Generation")

Configure image generation in your character file:

    {    "modelProvider": "heurist",    "settings": {        "imageSettings": {            "steps": 20,            "width": 1024,            "height": 1024        }    }}

Example usage:

    const result = await generateImage(    {        prompt: 'A cute anime girl with big breasts and straight long black hair wearing orange T-shirt. The T-shirt has "ai16z" texts in the front. The girl is looking at the viewer',        width: 1024,        height: 1024,        numIterations: 20, // optional        guidanceScale: 3, // optional        seed: -1, // optional        modelId: "FLUX.1-dev", // optional    },    runtime,);

Character Configuration[​](#character-configuration "Direct link to Character Configuration")
---------------------------------------------------------------------------------------------

### Character File Structure[​](#character-file-structure "Direct link to Character File Structure")

Character files define your agent's personality and behavior. Create them in the `characters/` directory:

    {    "name": "AgentName",    "clients": ["discord", "twitter"],    "modelProvider": "openai",    "settings": {        "secrets": {            "OPENAI_API_KEY": "character-specific-key",            "DISCORD_TOKEN": "bot-specific-token"        }    }}

### Loading Characters[​](#loading-characters "Direct link to Loading Characters")

You can load characters in several ways:

    # Load default characterpnpm start# Load specific characterpnpm start --characters="characters/your-character.json"# Load multiple characterspnpm start --characters="characters/char1.json,characters/char2.json"

Custom Actions[​](#custom-actions "Direct link to Custom Actions")
------------------------------------------------------------------

### Adding Custom Actions[​](#adding-custom-actions "Direct link to Adding Custom Actions")

1.  Create a `custom_actions` directory
2.  Add your action files there
3.  Configure in `elizaConfig.yaml`:

    actions:    - name: myCustomAction      path: ./custom_actions/myAction.ts

### Action Configuration Structure[​](#action-configuration-structure "Direct link to Action Configuration Structure")

    export const myAction: Action = {    name: "MY_ACTION",    similes: ["SIMILAR_ACTION", "ALTERNATE_NAME"],    validate: async (runtime: IAgentRuntime, message: Memory) => {        // Validation logic        return true;    },    description: "Action description",    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Action logic        return true;    },};

Provider Configuration[​](#provider-configuration "Direct link to Provider Configuration")
------------------------------------------------------------------------------------------

### Database Providers[​](#database-providers "Direct link to Database Providers")

Configure different database backends:

    // SQLite (Recommended for development)import { SqliteDatabaseAdapter } from "@your-org/agent-framework/adapters";const db = new SqliteDatabaseAdapter("./dev.db");// PostgreSQL (Production)import { PostgresDatabaseAdapter } from "@your-org/agent-framework/adapters";const db = new PostgresDatabaseAdapter({    host: process.env.DB_HOST,    port: parseInt(process.env.DB_PORT),    database: process.env.DB_NAME,    user: process.env.DB_USER,    password: process.env.DB_PASSWORD,});

### Model Providers[​](#model-providers "Direct link to Model Providers")

Configure model providers in your character file:

    {    "modelProvider": "openai",    "settings": {        "model": "gpt-4o-mini",        "temperature": 0.7,        "maxTokens": 2000    }}

Advanced Configuration[​](#advanced-configuration "Direct link to Advanced Configuration")
------------------------------------------------------------------------------------------

### Runtime Settings[​](#runtime-settings "Direct link to Runtime Settings")

Fine-tune runtime behavior:

    const settings = {    // Logging    DEBUG: "eliza:*",    LOG_LEVEL: "info",    // Performance    MAX_CONCURRENT_REQUESTS: 5,    REQUEST_TIMEOUT: 30000,    // Memory    MEMORY_TTL: 3600,    MAX_MEMORY_ITEMS: 1000,};

### Plugin Configuration[​](#plugin-configuration "Direct link to Plugin Configuration")

Enable and configure plugins in `elizaConfig.yaml`:

    plugins:    - name: solana      enabled: true      settings:          network: mainnet-beta          endpoint: https://api.mainnet-beta.solana.com    - name: image-generation      enabled: true      settings:          provider: dalle          size: 1024x1024

Configuration Best Practices[​](#configuration-best-practices "Direct link to Configuration Best Practices")
------------------------------------------------------------------------------------------------------------

1.  **Environment Segregation**
    
    *   Use different `.env` files for different environments
    *   Follow naming convention: `.env.development`, `.env.staging`, `.env.production`
2.  **Secret Management**
    
    *   Never commit secrets to version control
    *   Use secret management services in production
    *   Rotate API keys regularly
3.  **Character Configuration**
    
    *   Keep character files modular and focused
    *   Use inheritance for shared traits
    *   Document character behaviors
4.  **Plugin Management**
    
    *   Enable only needed plugins
    *   Configure plugin-specific settings in separate files
    *   Monitor plugin performance
5.  **Database Configuration**
    
    *   Use SQLite for development
    *   Configure connection pooling for production
    *   Set up proper indexes

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  **Environment Variables Not Loading**
    
        # Check .env file locationnode -e "console.log(require('path').resolve('.env'))"# Verify environment variablesnode -e "console.log(process.env)"
    
2.  **Character Loading Failures**
    
        # Validate character filenpx ajv validate -s character-schema.json -d your-character.json
    
3.  **Database Connection Issues**
    
        # Test database connectionnpx ts-node scripts/test-db-connection.ts
    

### Configuration Validation[​](#configuration-validation "Direct link to Configuration Validation")

Use the built-in config validator:

This will check:

*   Environment variables
*   Character files
*   Database configuration
*   Plugin settings

Further Resources[​](#further-resources "Direct link to Further Resources")
---------------------------------------------------------------------------

*   [Quickstart Guide](https://elizaos.github.io/eliza/docs/quickstart/) for initial setup
*   [Secrets Management](https://elizaos.github.io/eliza/docs/guides/secrets-management/) for secure configuration
*   [Local Development](https://elizaos.github.io/eliza/docs/guides/local-development/) for development setup
*   [Advanced Usage](https://elizaos.github.io/eliza/docs/guides/advanced/) for complex configurations</content>
</page>

<page>
  <title>🔌 Providers | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/core/providers/</url>
  <content>[Providers](https://elizaos.github.io/eliza/api/interfaces/provider/) are core modules that inject dynamic context and real-time information into agent interactions. They serve as a bridge between the agent and various external systems, enabling access to market data, wallet information, sentiment analysis, and temporal context.

* * *

Overview[​](#overview "Direct link to Overview")
------------------------------------------------

A provider's primary purpose is to:

*   Supply dynamic contextual information
*   Integrate with the agent runtime
*   Format information for conversation templates
*   Maintain consistent data access

### Core Structure[​](#core-structure "Direct link to Core Structure")

    interface Provider {    get: (        runtime: IAgentRuntime,        message: Memory,        state?: State,    ) => Promise<string>;}

* * *

Built-in Providers[​](#built-in-providers "Direct link to Built-in Providers")
------------------------------------------------------------------------------

### Time Provider[​](#time-provider "Direct link to Time Provider")

Provides temporal context for agent interactions:

    const timeProvider: Provider = {    get: async (_runtime: IAgentRuntime, _message: Memory) => {        const currentDate = new Date();        const currentTime = currentDate.toLocaleTimeString("en-US");        const currentYear = currentDate.getFullYear();        return `The current time is: ${currentTime}, ${currentYear}`;    },};

### Facts Provider[​](#facts-provider "Direct link to Facts Provider")

From bootstrap plugin - maintains conversation facts:

    const factsProvider: Provider = {    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {        // Create embedding for recent messages and retrieve relevant facts        const recentMessages = formatMessages({            messages: state?.recentMessagesData?.slice(-10),            actors: state?.actorsData,        });        const embedding = await embed(runtime, recentMessages);        const memoryManager = new MemoryManager({            runtime,            tableName: "facts",        });        const recentFactsData = await memoryManager.getMemories({            roomId: message.roomId,            count: 10,            agentId: runtime.agentId,        });        // Combine and format facts        const allFacts = [...recentFactsData]; // Deduplication can be skipped if no overlap        const formattedFacts = formatFacts(allFacts);        return `Key facts that ${runtime.character.name} knows:\n${formattedFacts}`;    },};export { factsProvider };

### Boredom Provider[​](#boredom-provider "Direct link to Boredom Provider")

From bootstrap plugin - manages conversation dynamics and engagement by calculating the boredom level of an agent based on recent messages in a chat room.

1.  **Data Structures**:
    
    *   **boredomLevels**: An array of objects, each representing a boredom level with a minimum score and a set of status messages that reflect the agent's current engagement.
    *   **interestWords**, **cringeWords**, and **negativeWords**: Arrays of words that influence the boredom score based on their presence in messages.
2.  **Boredom Calculation**:
    

*   The `boredomProvider` gets recent messages from the agent’s conversation over the last 15 minutes.
*   It calculates a **boredom score** by analyzing the text of these messages. The score is influenced by:
    *   **Interest words**: Decrease boredom (subtract 1 point).
    *   **Cringe words**: Increase boredom (add 1 point).
    *   **Negative words**: Increase boredom (add 1 point).
    *   **Exclamation marks**: Increase boredom (add 1 point).
    *   **Question marks**: Increase or decrease boredom depending on the sender.

3.  **Boredom Level**:
    *   The boredom score is matched to a level from the `boredomLevels` array, which defines how engaged the agent feels.
    *   A random status message from the selected boredom level is chosen and the agent’s name is inserted into the message.

    interface BoredomLevel {    minScore: number;    statusMessages: string[];}

The result is a message that reflects the agent's perceived level of engagement in the conversation, based on their recent interactions.

    const boredomProvider: Provider = {    get: async (runtime: IAgentRuntime, message: Memory) => {        const messages = await runtime.messageManager.getMemories({            roomId: message.roomId,            count: 10,        });        return messages.length > 0            ? "Actively engaged in conversation"            : "No recent interactions";    },};

Features:

*   Engagement tracking
*   Conversation flow management
*   Natural disengagement
*   Sentiment analysis
*   Response adaptation

* * *

Implementation[​](#implementation "Direct link to Implementation")
------------------------------------------------------------------

### Basic Provider Template[​](#basic-provider-template "Direct link to Basic Provider Template")

    import { Provider, IAgentRuntime, Memory, State } from "@elizaos/core";const customProvider: Provider = {    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {        // Get relevant data using runtime services        const memories = await runtime.messageManager.getMemories({            roomId: message.roomId,            count: 5,        });        // Format and return context        return formatContextString(memories);    },};

### Memory Integration[​](#memory-integration "Direct link to Memory Integration")

    const memoryProvider: Provider = {    get: async (runtime: IAgentRuntime, message: Memory) => {        // Get recent messages        const messages = await runtime.messageManager.getMemories({            roomId: message.roomId,            count: 5,            unique: true,        });        // Get user descriptions        const descriptions = await runtime.descriptionManager.getMemories({            roomId: message.roomId,            userId: message.userId,        });        // Combine and format        return `Recent Activity:${formatMessages(messages)}User Context:${formatDescriptions(descriptions)}    `.trim();    },};

* * *

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### 1\. Data Management[​](#1-data-management "Direct link to 1. Data Management")

*   Implement robust caching strategies
*   Use appropriate TTL for different data types
*   Validate data before caching

### 2\. Performance[​](#2-performance "Direct link to 2. Performance")

    // Example of optimized data fetchingasync function fetchDataWithCache<T>(    key: string,    fetcher: () => Promise<T>,): Promise<T> {    const cached = await cache.get(key);    if (cached) return cached;    const data = await fetcher();    await cache.set(key, data);    return data;}

### 3\. Error Handling[​](#3-error-handling "Direct link to 3. Error Handling")

*   Implement retry mechanisms
*   Provide fallback values
*   Log errors comprehensively
*   Handle API timeouts

### 4\. Security[​](#4-security "Direct link to 4. Security")

*   Validate input parameters
*   Sanitize returned data
*   Implement rate limiting
*   Handle sensitive data appropriately

* * *

Integration with Runtime[​](#integration-with-runtime "Direct link to Integration with Runtime")
------------------------------------------------------------------------------------------------

Providers are registered with the [AgentRuntime](https://elizaos.github.io/eliza/api/classes/AgentRuntime/):

    // Register providerruntime.registerContextProvider(customProvider);// Providers are accessed through composeStateconst state = await runtime.composeState(message);

Example: Complete Provider[​](#example-complete-provider "Direct link to Example: Complete Provider")
-----------------------------------------------------------------------------------------------------

    import { Provider, IAgentRuntime, Memory, State } from "@elizaos/core";const comprehensiveProvider: Provider = {    get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {        try {            // Get recent messages            const messages = await runtime.messageManager.getMemories({                roomId: message.roomId,                count: 5,            });            // Get user context            const userContext = await runtime.descriptionManager.getMemories({                roomId: message.roomId,                userId: message.userId,            });            // Get relevant facts            const facts = await runtime.messageManager.getMemories({                roomId: message.roomId,                tableName: "facts",                count: 3,            });            // Format comprehensive context            return `# Conversation Context${messages.map((m) => `- ${m.content.text}`).join("\n")}# User Information${userContext.map((c) => c.content.text).join("\n")}# Related Facts${facts.map((f) => `- ${f.content.text}`).join("\n")}      `.trim();        } catch (error) {            console.error("Provider error:", error);            return "Context temporarily unavailable";        }    },};

* * *

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

1.  **Stale Data**
    
        // Implement cache invalidationconst invalidateCache = async (pattern: string) => {    const keys = await cache.keys(pattern);    await Promise.all(keys.map((k) => cache.del(k)));};
    
2.  **Rate Limiting**
    
        // Implement backoff strategyconst backoff = async (attempt: number) => {    const delay = Math.min(1000 * Math.pow(2, attempt), 10000);    await new Promise((resolve) => setTimeout(resolve, delay));};
    
3.  **API Failures**
    
        // Implement fallback data sourcesconst getFallbackData = async () => {    // Attempt alternative data sources};
    

* * *

Further Reading[​](#further-reading "Direct link to Further Reading")
---------------------------------------------------------------------

*   [Agent Runtime](https://elizaos.github.io/eliza/docs/core/agents/)
*   [Memory System](https://elizaos.github.io/eliza/docs/packages/core/)</content>
</page>

<page>
  <title>WSL Setup Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/guides/wsl/</url>
  <content>Steps to run Eliza on Windows computer using WSL. [AI Dev School Tutorial](https://www.youtube.com/watch?v=ArptLpQiKfI)

Install WSL[​](#install-wsl "Direct link to Install WSL")
---------------------------------------------------------

1.  Open PowerShell as Administrator and run:

2.  Restart your computer
3.  Launch Ubuntu from the Start menu and create your Linux username/password

Install Dependencies[​](#install-dependencies "Direct link to Install Dependencies")
------------------------------------------------------------------------------------

1.  Update Ubuntu packages:

    sudo apt update && sudo apt upgrade -y

2.  Install system dependencies:

    sudo apt install -y \    build-essential \    python3 \    python3-pip \    git \    curl \    ffmpeg \    libtool-bin \    autoconf \    automake \    libopus-dev

3.  Install Node.js via nvm:

    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bashsource ~/.bashrcnvm install 23nvm use 23

4.  Install pnpm:

    curl -fsSL https://get.pnpm.io/install.sh | sh -source ~/.bashrc

Optional: CUDA Support[​](#optional-cuda-support "Direct link to Optional: CUDA Support")
-----------------------------------------------------------------------------------------

If you have an NVIDIA GPU and want CUDA support:

1.  Install CUDA Toolkit on Windows from [NVIDIA's website](https://developer.nvidia.com/cuda-downloads)
2.  WSL will automatically detect and use the Windows CUDA installation

Clone and Setup Eliza[​](#clone-and-setup-eliza "Direct link to Clone and Setup Eliza")
---------------------------------------------------------------------------------------

Follow the [Quickstart Guide](https://elizaos.github.io/eliza/docs/quickstart/) starting from the "Installation" section.

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

*   If you encounter `node-gyp` errors, ensure build tools are installed:

    sudo apt install -y nodejs-dev node-gyp

*   For audio-related issues, verify ffmpeg installation:

*   For permission issues, ensure your user owns the project directory:

    sudo chown -R $USER:$USER ~/path/to/eliza</content>
</page>

<page>
  <title>🔧 Advanced Usage Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/guides/advanced/</url>
  <content>This guide covers advanced features and capabilities of Eliza, including complex integrations, custom services, and specialized plugins.

Service Integration[​](#service-integration "Direct link to Service Integration")
---------------------------------------------------------------------------------

### Video Processing Service[​](#video-processing-service "Direct link to Video Processing Service")

Eliza supports advanced video processing capabilities through the `VideoService`:

    import { VideoService } from "@elizaos/core/plugin-node";// Initialize serviceconst videoService = new VideoService();// Process video contentconst result = await videoService.processVideo(url, runtime);

Key features:

*   Automatic video downloading
*   Transcription support
*   Subtitle extraction
*   Cache management
*   Queue processing

### Image Processing[​](#image-processing "Direct link to Image Processing")

The `ImageDescriptionService` provides advanced image analysis:

    import { ImageDescriptionService } from "@elizaos/core/plugin-node";const imageService = new ImageDescriptionService();const description = await imageService.describeImage(imageUrl, "gpu", runtime);

Features:

*   Local and cloud processing options
*   CUDA acceleration support
*   Automatic format handling
*   GIF frame extraction

Blockchain Integration[​](#blockchain-integration "Direct link to Blockchain Integration")
------------------------------------------------------------------------------------------

### Solana Integration[​](#solana-integration "Direct link to Solana Integration")

The Solana plugin provides comprehensive blockchain functionality:

    import { solanaPlugin } from "@elizaos/core/plugin-solana";// Initialize pluginruntime.registerPlugin(solanaPlugin);

#### Token Operations[​](#token-operations "Direct link to Token Operations")

    // Buy tokensconst swapResult = await swapToken(    connection,    walletPublicKey,    inputTokenCA,    outputTokenCA,    amount,);// Sell tokensconst sellResult = await sellToken({    sdk,    seller: walletKeypair,    mint: tokenMint,    amount: sellAmount,    priorityFee,    allowOffCurve: false,    slippage: "1",    connection,});

#### Trust Score System[​](#trust-score-system "Direct link to Trust Score System")

    const trustScoreManager = new TrustScoreManager(tokenProvider, trustScoreDb);// Generate trust scoresconst score = await trustScoreManager.generateTrustScore(    tokenAddress,    recommenderId,    recommenderWallet,);// Monitor trade performanceawait trustScoreManager.createTradePerformance(runtime, tokenAddress, userId, {    buy_amount: amount,    is_simulation: false,});

Custom Services[​](#custom-services "Direct link to Custom Services")
---------------------------------------------------------------------

### Speech Generation[​](#speech-generation "Direct link to Speech Generation")

Implement text-to-speech capabilities:

    class SpeechService extends Service implements ISpeechService {    async generate(runtime: IAgentRuntime, text: string): Promise<Readable> {        if (runtime.getSetting("ELEVENLABS_XI_API_KEY")) {            return textToSpeech(runtime, text);        }        const { audio } = await synthesize(text, {            engine: "vits",            voice: "en_US-hfc_female-medium",        });        return Readable.from(audio);    }}

### PDF Processing[​](#pdf-processing "Direct link to PDF Processing")

Handle PDF document analysis:

    class PdfService extends Service {    async convertPdfToText(pdfBuffer: Buffer): Promise<string> {        const pdf = await getDocument({ data: pdfBuffer }).promise;        const numPages = pdf.numPages;        const textPages = [];        for (let pageNum = 1; pageNum <= numPages; pageNum++) {            const page = await pdf.getPage(pageNum);            const textContent = await page.getTextContent();            const pageText = textContent.items                .filter(isTextItem)                .map((item) => item.str)                .join(" ");            textPages.push(pageText);        }        return textPages.join("\n");    }}

Advanced Memory Management[​](#advanced-memory-management "Direct link to Advanced Memory Management")
------------------------------------------------------------------------------------------------------

### Retrievable Memory System[​](#retrievable-memory-system "Direct link to Retrievable Memory System")

    class MemoryManager {    async getMemories({        agentId,        roomId,        count,    }: {        agentId: string;        roomId: string;        count: number;    }): Promise<Memory[]> {        // Implement memory retrieval logic    }    async createMemory(        memory: Memory,        allowDuplicates: boolean = false,    ): Promise<void> {        // Implement memory storage logic    }}

### Trust Score Database[​](#trust-score-database "Direct link to Trust Score Database")

Implement advanced scoring systems:

    class TrustScoreDatabase {    async calculateValidationTrust(tokenAddress: string): number {        const sql = `      SELECT rm.trust_score      FROM token_recommendations tr      JOIN recommender_metrics rm ON tr.recommender_id = rm.recommender_id      WHERE tr.token_address = ?;    `;        const rows = this.db.prepare(sql).all(tokenAddress);        if (rows.length === 0) return 0;        const totalTrust = rows.reduce((acc, row) => acc + row.trust_score, 0);        return totalTrust / rows.length;    }}

Plugin Development[​](#plugin-development "Direct link to Plugin Development")
------------------------------------------------------------------------------

### Creating Custom Plugins[​](#creating-custom-plugins "Direct link to Creating Custom Plugins")

    const customPlugin: Plugin = {    name: "custom-plugin",    description: "Custom Plugin for Eliza",    actions: [        // Custom actions    ],    evaluators: [        // Custom evaluators    ],    providers: [        // Custom providers    ],};

### Advanced Action Development[​](#advanced-action-development "Direct link to Advanced Action Development")

    export const complexAction: Action = {    name: "COMPLEX_ACTION",    similes: ["ALTERNATIVE_NAME", "OTHER_NAME"],    validate: async (runtime: IAgentRuntime, message: Memory) => {        // Implement validation logic        return true;    },    handler: async (        runtime: IAgentRuntime,        message: Memory,        state: State,        options: { [key: string]: unknown },        callback?: HandlerCallback,    ): Promise<boolean> => {        // Implement complex handling logic        return true;    },};

Advanced Configuration[​](#advanced-configuration "Direct link to Advanced Configuration")
------------------------------------------------------------------------------------------

### Custom Runtime Configuration[​](#custom-runtime-configuration "Direct link to Custom Runtime Configuration")

    const customRuntime = new AgentRuntime({    databaseAdapter: new PostgresDatabaseAdapter(config),    modelProvider: new OpenAIProvider(apiKey),    plugins: [solanaPlugin, customPlugin],    services: [        new VideoService(),        new ImageDescriptionService(),        new SpeechService(),    ],});

### Advanced Model Configuration[​](#advanced-model-configuration "Direct link to Advanced Model Configuration")

    const modelConfig = {    modelClass: ModelClass.LARGE,    temperature: 0.7,    maxTokens: 2000,    topP: 0.9,    frequencyPenalty: 0.5,    presencePenalty: 0.5,};const response = await generateText({    runtime,    context: prompt,    ...modelConfig,});

Performance Optimization[​](#performance-optimization "Direct link to Performance Optimization")
------------------------------------------------------------------------------------------------

### Caching Strategy[​](#caching-strategy "Direct link to Caching Strategy")

    class CacheManager {    private cache: NodeCache;    private cacheDir: string;    constructor() {        this.cache = new NodeCache({ stdTTL: 300 });        this.cacheDir = path.join(__dirname, "cache");        this.ensureCacheDirectoryExists();    }    private async getCachedData<T>(key: string): Promise<T | null> {        // Implement tiered caching strategy    }}

### Queue Management[​](#queue-management "Direct link to Queue Management")

    class QueueManager {    private queue: string[] = [];    private processing: boolean = false;    async processQueue(): Promise<void> {        if (this.processing || this.queue.length === 0) {            return;        }        this.processing = true;        while (this.queue.length > 0) {            const item = this.queue.shift();            await this.processItem(item);        }        this.processing = false;    }}

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### Error Handling[​](#error-handling "Direct link to Error Handling")

    try {    const result = await complexOperation();    if (!result) {        throw new Error("Operation failed");    }    return result;} catch (error) {    console.error("Error in operation:", error);    await errorReporting.log(error);    throw new OperationalError("Failed to complete operation", {        cause: error,    });}

### Resource Management[​](#resource-management "Direct link to Resource Management")

    class ResourceManager {    private resources: Map<string, Resource> = new Map();    async acquire(id: string): Promise<Resource> {        // Implement resource acquisition with timeout    }    async release(id: string): Promise<void> {        // Implement resource cleanup    }}

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  Memory Leaks
    
    *   Monitor memory usage
    *   Implement proper cleanup
    *   Use WeakMap for caching
2.  Performance Bottlenecks
    
    *   Profile slow operations
    *   Implement batching
    *   Use connection pooling
3.  Integration Issues
    
    *   Verify API credentials
    *   Check network connectivity
    *   Validate request formatting

### Debugging[​](#debugging "Direct link to Debugging")

    const debug = require("debug")("eliza:advanced");debug("Detailed operation info: %O", {    operation: "complexOperation",    parameters: params,    result: result,});

Further Resources[​](#further-resources "Direct link to Further Resources")
---------------------------------------------------------------------------

*   [Infrastructure Guide](https://elizaos.github.io/eliza/docs/advanced/infrastructure/) for deployment
*   [Trust Engine Documentation](https://elizaos.github.io/eliza/docs/advanced/trust-engine/) for scoring system
*   [Autonomous Trading Guide](https://elizaos.github.io/eliza/docs/advanced/autonomous-trading/) for trading features
*   [Fine-tuning Guide](https://elizaos.github.io/eliza/docs/advanced/fine-tuning/) for model optimization
*   [Eliza in TEE](https://elizaos.github.io/eliza/docs/advanced/eliza-in-tee/) for TEE integration</content>
</page>

<page>
  <title>🏗️ Infrastructure Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/advanced/infrastructure/</url>
  <content>Eliza's infrastructure is built on a flexible database architecture that supports multiple adapters and efficient data storage mechanisms for AI agent interactions, memory management, and relationship tracking.

    - accounts: User and agent identities- rooms: Conversation spaces- memories: Vector-indexed message storage- goals: Agent objectives and progress- participants: Room membership tracking- relationships: Inter-agent connections

    -- Create base tablesCREATE TABLE accounts (    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,    "name" TEXT,    "username" TEXT UNIQUE,    "email" TEXT NOT NULL UNIQUE,    "avatarUrl" TEXT,    "details" JSONB DEFAULT '{}'::jsonb);CREATE TABLE rooms (    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP);CREATE TABLE memories (    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),    "type" TEXT NOT NULL,    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,    "content" JSONB NOT NULL,    "embedding" vector(1536),    "userId" UUID REFERENCES accounts("id"),    "agentId" UUID REFERENCES accounts("id"),    "roomId" UUID REFERENCES rooms("id"),    "isUnique" BOOLEAN DEFAULT true NOT NULL);CREATE TABLE participants (    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),    "userId" UUID REFERENCES accounts("id"),    "roomId" UUID REFERENCES rooms("id"),    "joinedAt" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP);

    CREATE INDEX idx_memories_embedding ON memories    USING hnsw ("embedding" vector_cosine_ops);CREATE INDEX idx_memories_type_room ON memories("type", "roomId");CREATE INDEX idx_participants_user ON participants("userId");CREATE INDEX idx_participants_room ON participants("roomId");

    async function storeMemory(runtime: IAgentRuntime, content: string) {  const embedding = await runtime.embed(content);  await runtime.databaseAdapter.createMemory({    type: "message",    content: { text: content },    embedding,    roomId: roomId,    userId: userId,  });}

    -- Create application roleCREATE ROLE app_user;-- Grant necessary permissionsGRANT SELECT, INSERT ON memories TO app_user;GRANT USAGE ON SCHEMA public TO app_user;

    CREATE TABLE logs (    "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),    "createdAt" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,    "userId" UUID NOT NULL REFERENCES accounts("id"),    "body" JSONB NOT NULL,    "type" TEXT NOT NULL,    "roomId" UUID NOT NULL REFERENCES rooms("id"));

    -- Check connection statusSELECT * FROM pg_stat_activity;-- Analyze query performanceEXPLAIN ANALYZESELECT * FROM memoriesWHERE embedding <-> $1 < 0.3LIMIT 10;-- Monitor index usageSELECT schemaname, tablename, indexname, idx_scanFROM pg_stat_user_indexes;</content>
</page>

<page>
  <title>📖 Package Overview | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/packages/</url>
  <content>Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

*   **@elizaos/core**: Central framework and shared functionality
*   **@elizaos/agent**: Agent runtime and management
*   **@elizaos/adapters**: Database implementations (PostgreSQL, SQLite, etc.)
*   **@elizaos/clients**: Platform integrations (Discord, Telegram, etc.)
*   **@elizaos/plugins**: Extension modules for additional functionality

Package Architecture[​](#package-architecture "Direct link to Package Architecture")
------------------------------------------------------------------------------------

The Eliza framework is built on a modular architecture where each package serves a specific purpose:

1.  **Core Package**: Provides the fundamental building blocks
2.  **Agent Package**: Handles agent lifecycle and runtime
3.  **Adapters**: Enable different storage backends
4.  **Clients**: Connect to various platforms
5.  **Plugins**: Add specialized capabilities

Package Dependencies[​](#package-dependencies "Direct link to Package Dependencies")
------------------------------------------------------------------------------------

Getting Started[​](#getting-started "Direct link to Getting Started")
---------------------------------------------------------------------

    # Install core packagepnpm add @elizaos/core# Install specific adapterspnpm add @elizaos/adapter-postgrespnpm add @elizaos/adapter-sqlite# Install clientspnpm add @elizaos/client-discordpnpm add @elizaos/client-Telegram</content>
</page>

<page>
  <title>🔐 Secrets Management | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/guides/secrets-management/</url>
  <content>A comprehensive guide for managing secrets, API keys, and sensitive configuration in Eliza.

Core Concepts[​](#core-concepts "Direct link to Core Concepts")
---------------------------------------------------------------

### Environment Variables[​](#environment-variables "Direct link to Environment Variables")

Eliza uses a hierarchical environment variable system:

1.  Character-specific namespaced environment variables (highest priority)
2.  Character-specific secrets
3.  Environment variables
4.  Default values (lowest priority)

### Secret Types[​](#secret-types "Direct link to Secret Types")

Common secrets you'll need to manage:

    # API KeysOPENAI_API_KEY=sk-*ANTHROPIC_API_KEY=your-keyELEVENLABS_XI_API_KEY=your-keyGOOGLE_GENERATIVE_AI_API_KEY=your-key# Client AuthenticationDISCORD_API_TOKEN=your-tokenTELEGRAM_BOT_TOKEN=your-token# Database CredentialsSUPABASE_URL=your-urlSUPABASE_SERVICE_API_KEY=your-key# EVMEVM_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEY# SolanaSOLANA_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEYSOLANA_PUBLIC_KEY=EXAMPLE_WALLET_PUBLIC_KEY# Fallback Wallet Configuration (deprecated)WALLET_PRIVATE_KEY=EXAMPLE_WALLET_PRIVATE_KEYWALLET_PUBLIC_KEY=EXAMPLE_WALLET_PUBLIC_KEY

Implementation Guide[​](#implementation-guide "Direct link to Implementation Guide")
------------------------------------------------------------------------------------

### Basic Setup[​](#basic-setup "Direct link to Basic Setup")

1.  Create a `.env` file from template:

2.  Configure environment discovery:

    import { config } from "dotenv";import path from "path";export function findNearestEnvFile(startDir = process.cwd()) {  let currentDir = startDir;  while (currentDir !== path.parse(currentDir).root) {    const envPath = path.join(currentDir, ".env");    if (fs.existsSync(envPath)) {      return envPath;    }    currentDir = path.dirname(currentDir);  }  return null;}

### Character-Specific Secrets[​](#character-specific-secrets "Direct link to Character-Specific Secrets")

Define secrets in character files:

    {  "name": "TradingBot",  "settings": {    "secrets": {      "OPENAI_API_KEY": "character-specific-key",      "WALLET_PRIVATE_KEY": "character-specific-wallet"    }  }}

Alternatively, you can use the `CHARACTER.YOUR_CHARACTER_NAME.SECRET_NAME` format inside your `.env` file.

Access secrets in code:

    const apiKey = runtime.getSetting("OPENAI_API_KEY");

### Secure Storage[​](#secure-storage "Direct link to Secure Storage")

#### Database Secrets[​](#database-secrets "Direct link to Database Secrets")

Use encrypted connection strings:

    class SecureDatabase {  private connection: Connection;  constructor(encryptedConfig: string) {    const config = this.decryptConfig(encryptedConfig);    this.connection = new Connection(config);  }  private decryptConfig(encrypted: string): DatabaseConfig {    // Implement decryption logic    return JSON.parse(decrypted);  }}

#### Wallet Management[​](#wallet-management "Direct link to Wallet Management")

Secure handling of blockchain credentials:

    class WalletManager {  private async initializeWallet(runtime: IAgentRuntime) {    const privateKey =      runtime.getSetting("SOLANA_PRIVATE_KEY") ??      runtime.getSetting("WALLET_PRIVATE_KEY");    if (!privateKey) {      throw new Error("Wallet private key not configured");    }    // Validate key format    try {      const keyBuffer = Buffer.from(privateKey, "base64");      if (keyBuffer.length !== 64) {        throw new Error("Invalid key length");      }    } catch (error) {      throw new Error("Invalid private key format");    }    // Initialize wallet securely    return new Wallet(privateKey);  }}

### Secret Rotation[​](#secret-rotation "Direct link to Secret Rotation")

Implement automatic secret rotation:

    class SecretRotation {  private static readonly SECRET_LIFETIME = 90 * 24 * 60 * 60 * 1000; // 90 days  async shouldRotateSecret(secretName: string): Promise<boolean> {    const lastRotation = await this.getLastRotation(secretName);    return Date.now() - lastRotation > SecretRotation.SECRET_LIFETIME;  }  async rotateSecret(secretName: string): Promise<void> {    // Implement rotation logic    const newSecret = await this.generateNewSecret();    await this.updateSecret(secretName, newSecret);    await this.recordRotation(secretName);  }}

### Access Control[​](#access-control "Direct link to Access Control")

Implement proper access controls:

    class SecretAccess {  private static readonly ALLOWED_KEYS = [    "OPENAI_API_KEY",    "DISCORD_TOKEN",    // ... other allowed keys  ];  static validateAccess(key: string): boolean {    return this.ALLOWED_KEYS.includes(key);  }  static async getSecret(    runtime: IAgentRuntime,    key: string,  ): Promise<string | null> {    if (!this.validateAccess(key)) {      throw new Error(`Unauthorized access to secret: ${key}`);    }    return runtime.getSetting(key);  }}

### Encryption at Rest[​](#encryption-at-rest "Direct link to Encryption at Rest")

Implement encryption for stored secrets:

    import { createCipheriv, createDecipheriv } from "crypto";class SecretEncryption {  static async encrypt(value: string, key: Buffer): Promise<string> {    const iv = crypto.randomBytes(16);    const cipher = createCipheriv("aes-256-gcm", key, iv);    let encrypted = cipher.update(value, "utf8", "hex");    encrypted += cipher.final("hex");    return JSON.stringify({      iv: iv.toString("hex"),      encrypted,      tag: cipher.getAuthTag().toString("hex"),    });  }  static async decrypt(encrypted: string, key: Buffer): Promise<string> {    const { iv, encrypted: encryptedData, tag } = JSON.parse(encrypted);    const decipher = createDecipheriv(      "aes-256-gcm",      key,      Buffer.from(iv, "hex"),    );    decipher.setAuthTag(Buffer.from(tag, "hex"));    let decrypted = decipher.update(encryptedData, "hex", "utf8");    decrypted += decipher.final("utf8");    return decrypted;  }}

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### 1\. Environment Segregation[​](#1-environment-segregation "Direct link to 1. Environment Segregation")

Maintain separate environment files:

    .env.development    # Local development settings.env.staging       # Staging environment.env.production    # Production settings

### 2\. Git Security[​](#2-git-security "Direct link to 2. Git Security")

Exclude sensitive files:

    # .gitignore.env.env.*characters/**/secrets.json**/serviceAccount.json

### 3\. Secret Validation[​](#3-secret-validation "Direct link to 3. Secret Validation")

Validate secrets before use:

    async function validateSecrets(character: Character): Promise<void> {  const required = ["OPENAI_API_KEY"];  const missing = required.filter((key) => !character.settings.secrets[key]);  if (missing.length > 0) {    throw new Error(`Missing required secrets: ${missing.join(", ")}`);  }}

### 4\. Error Handling[​](#4-error-handling "Direct link to 4. Error Handling")

Secure error messages:

    try {  await loadSecrets();} catch (error) {  if (error.code === "ENOENT") {    console.error("Environment file not found");  } else if (error instanceof ValidationError) {    console.error("Invalid secret format");  } else {    // Log securely without exposing secret values    console.error("Error loading secrets");  }}

Security Considerations[​](#security-considerations "Direct link to Security Considerations")
---------------------------------------------------------------------------------------------

### 1\. Handling API Keys[​](#1-handling-api-keys "Direct link to 1. Handling API Keys")

    class APIKeyManager {  private validateAPIKey(key: string): boolean {    if (key.startsWith("sk-")) {      return key.length > 20;    }    return false;  }  async rotateAPIKey(provider: string): Promise<void> {    // Implement key rotation logic  }}

### 2\. Secure Configuration Loading[​](#2-secure-configuration-loading "Direct link to 2. Secure Configuration Loading")

    class ConfigLoader {  private static sanitizePath(path: string): boolean {    return !path.includes("../") && !path.startsWith("/");  }  async loadConfig(path: string): Promise<Config> {    if (!this.sanitizePath(path)) {      throw new Error("Invalid config path");    }    // Load configuration  }}

### 3\. Memory Security[​](#3-memory-security "Direct link to 3. Memory Security")

    class SecureMemory {  private secrets: Map<string, WeakRef<string>> = new Map();  set(key: string, value: string): void {    this.secrets.set(key, new WeakRef(value));  }  get(key: string): string | null {    const ref = this.secrets.get(key);    return ref?.deref() ?? null;  }}

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  Missing Secrets

    if (!process.env.OPENAI_API_KEY) {  throw new Error(    "OpenAI API key not found in environment or character settings",  );}

2.  Invalid Secret Format

    function validateApiKey(key: string): boolean {  // OpenAI keys start with 'sk-'  if (key.startsWith("sk-")) {    return key.length > 20;  }  return false;}

3.  Secret Loading Errors

    try {  await loadSecrets();} catch (error) {  if (error.response) {    console.error("Response data:", error.response.data);    console.error("Response status:", error.response.status);  } else if (error.request) {    console.error("No response received:", error.request);  } else {    console.error("Error setting up request:", error.message);  }}

*   [Configuration Guide](https://elizaos.github.io/eliza/docs/guides/configuration/) for general setup
*   [Local Development](https://elizaos.github.io/eliza/docs/guides/local-development/) for development environment
*   [Infrastructure Guide](https://elizaos.github.io/eliza/docs/advanced/infrastructure/) for deployment security</content>
</page>

<page>
  <title>💻 Local Development Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/guides/local-development/</url>
  <content>This guide covers setting up and working with Eliza in a development environment.

Prerequisites[​](#prerequisites "Direct link to Prerequisites")
---------------------------------------------------------------

Before you begin, ensure you have:

    # RequiredNode.js 23+pnpmGit# Optional but recommendedVS CodeDocker (for database development)CUDA Toolkit (for GPU acceleration)

Initial Setup[​](#initial-setup "Direct link to Initial Setup")
---------------------------------------------------------------

### 1\. Repository Setup[​](#1-repository-setup "Direct link to 1. Repository Setup")

    # Clone the repositorygit clone https://github.com/elizaos/eliza.gitcd eliza# Install dependenciespnpm install# Install optional dependenciespnpm install --include=optional sharp

### 2\. Environment Configuration[​](#2-environment-configuration "Direct link to 2. Environment Configuration")

Create your development environment file:

Configure essential development variables:

    # Minimum required for local developmentOPENAI_API_KEY=sk-*           # Optional, for OpenAI featuresX_SERVER_URL=                 # Leave blank for local inferenceXAI_API_KEY=                 # Leave blank for local inferenceXAI_MODEL=meta-llama/Llama-3.1-7b-instruct  # Local model

### 3\. Local Model Setup[​](#3-local-model-setup "Direct link to 3. Local Model Setup")

For local inference without API dependencies:

    # Install CUDA support for NVIDIA GPUsnpx --no node-llama-cpp source download --gpu cuda# The system will automatically download models from# Hugging Face on first run

Development Workflow[​](#development-workflow "Direct link to Development Workflow")
------------------------------------------------------------------------------------

### Running the Development Server[​](#running-the-development-server "Direct link to Running the Development Server")

    # Start with default characterpnpm run dev# Start with specific characterpnpm run dev --characters="characters/my-character.json"# Start with multiple characterspnpm run dev --characters="characters/char1.json,characters/char2.json"

### Development Commands[​](#development-commands "Direct link to Development Commands")

    pnpm run build          # Build the projectpnpm run clean         # Clean build artifactspnpm run dev           # Start development serverpnpm run test          # Run testspnpm run test:watch    # Run tests in watch modepnpm run lint          # Lint code

### Direct Client Chat UI[​](#direct-client-chat-ui "Direct link to Direct Client Chat UI")

    # Open a terminal and Start with specific characterpnpm run dev --characters="characters/my-character.json"

    # Open a 2nd terminal and start the clientpnpm start:client

Look for the message: `➜ Local: http://localhost:5173/` Click on that link or open a browser window to that location. Once you do that you should see the chat interface connect with the system and you can start interacting with your character.

Database Development[​](#database-development "Direct link to Database Development")
------------------------------------------------------------------------------------

### SQLite (Recommended for Development)[​](#sqlite-recommended-for-development "Direct link to SQLite (Recommended for Development)")

    import { SqliteDatabaseAdapter } from "@elizaos/core/adapters";import Database from "better-sqlite3";const db = new SqliteDatabaseAdapter(new Database("./dev.db"));

### In-Memory Database (for Testing)[​](#in-memory-database-for-testing "Direct link to In-Memory Database (for Testing)")

    import { SqlJsDatabaseAdapter } from "@elizaos/core/adapters";const db = new SqlJsDatabaseAdapter(new Database(":memory:"));

### Schema Management[​](#schema-management "Direct link to Schema Management")

    # Create new migrationpnpm run migration:create# Run migrationspnpm run migration:up# Rollback migrationspnpm run migration:down

Testing[​](#testing "Direct link to Testing")
---------------------------------------------

### Running Tests[​](#running-tests "Direct link to Running Tests")

    # Run all testspnpm test# Run specific test filepnpm test tests/specific.test.ts# Run tests with coveragepnpm test:coverage# Run database-specific testspnpm test:sqlitepnpm test:sqljs

### Writing Tests[​](#writing-tests "Direct link to Writing Tests")

    import { runAiTest } from "@elizaos/core/test_resources";describe("Feature Test", () => {    beforeEach(async () => {        // Setup test environment    });    it("should perform expected behavior", async () => {        const result = await runAiTest({            messages: [                {                    user: "user1",                    content: { text: "test message" },                },            ],            expected: "expected response",        });        expect(result.success).toBe(true);    });});

Plugin Development[​](#plugin-development "Direct link to Plugin Development")
------------------------------------------------------------------------------

### Creating a New Plugin[​](#creating-a-new-plugin "Direct link to Creating a New Plugin")

    // plugins/my-plugin/src/index.tsimport { Plugin } from "@elizaos/core/types";export const myPlugin: Plugin = {    name: "my-plugin",    description: "My custom plugin",    actions: [],    evaluators: [],    providers: [],};

### Custom Action Development[​](#custom-action-development "Direct link to Custom Action Development")

    // plugins/my-plugin/src/actions/myAction.tsexport const myAction: Action = {    name: "MY_ACTION",    similes: ["SIMILAR_ACTION"],    validate: async (runtime: IAgentRuntime, message: Memory) => {        return true;    },    handler: async (runtime: IAgentRuntime, message: Memory) => {        // Implementation        return true;    },    examples: [],};

Debugging[​](#debugging "Direct link to Debugging")
---------------------------------------------------

### VS Code Configuration[​](#vs-code-configuration "Direct link to VS Code Configuration")

Create `.vscode/launch.json`:

    {    "version": "0.2.0",    "configurations": [        {            "type": "node",            "request": "launch",            "name": "Debug Eliza",            "skipFiles": ["<node_internals>/**"],            "program": "${workspaceFolder}/src/index.ts",            "runtimeArgs": ["-r", "ts-node/register"],            "env": {                "DEBUG": "eliza:*"            }        }    ]}

### Debugging Tips[​](#debugging-tips "Direct link to Debugging Tips")

1.  Enable Debug Logging

    # Add to your .env fileDEBUG=eliza:*

2.  Use Debug Points

    const debug = require("debug")("eliza:dev");debug("Operation details: %O", {    operation: "functionName",    params: parameters,    result: result,});

3.  Memory Debugging

    # Increase Node.js memory for developmentNODE_OPTIONS="--max-old-space-size=8192" pnpm run dev

Common Development Tasks[​](#common-development-tasks "Direct link to Common Development Tasks")
------------------------------------------------------------------------------------------------

### 1\. Adding a New Character[​](#1-adding-a-new-character "Direct link to 1. Adding a New Character")

    {    "name": "DevBot",    "description": "Development testing bot",    "modelProvider": "openai",    "settings": {        "debug": true,        "logLevel": "debug"    }}

### 2\. Creating Custom Services[​](#2-creating-custom-services "Direct link to 2. Creating Custom Services")

    class CustomService extends Service {    static serviceType = ServiceType.CUSTOM;    async initialize() {        // Setup code    }    async process(input: any): Promise<any> {        // Service logic    }}

### 3\. Working with Models[​](#3-working-with-models "Direct link to 3. Working with Models")

    // Local model configurationconst localModel = {    modelProvider: "llamalocal",    settings: {        modelPath: "./models/llama-7b.gguf",        contextSize: 8192,    },};// Cloud model configurationconst cloudModel = {    modelProvider: "openai",    settings: {        model: "gpt-4o-mini",        temperature: 0.7,    },};

Performance Optimization[​](#performance-optimization "Direct link to Performance Optimization")
------------------------------------------------------------------------------------------------

### CUDA Setup[​](#cuda-setup "Direct link to CUDA Setup")

For NVIDIA GPU users:

1.  Install CUDA Toolkit with cuDNN and cuBLAS
2.  Set environment variables:

    CUDA_PATH=/usr/local/cuda  # Windows: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0

### Memory Management[​](#memory-management "Direct link to Memory Management")

    class MemoryManager {    private cache = new Map();    private maxSize = 1000;    async cleanup() {        if (this.cache.size > this.maxSize) {            // Implement cleanup logic        }    }}

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  Model Loading Issues

    # Clear model cacherm -rf ./models/*# Restart with fresh download

2.  Database Connection Issues

    # Test database connectionpnpm run test:db-connection

3.  Memory Issues

    # Check memory usagenode --trace-gc index.js

### Development Tools[​](#development-tools "Direct link to Development Tools")

    # Generate TypeScript documentationpnpm run docs:generate# Check for circular dependenciespnpm run madge# Analyze bundle sizepnpm run analyze

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

1.  Code Organization
    
    *   Place custom actions in `custom_actions/`
    *   Keep character files in `characters/`
    *   Store test data in `tests/fixtures/`
2.  Testing Strategy
    
    *   Write unit tests for new features
    *   Use integration tests for plugins
    *   Test with multiple model providers
3.  Git Workflow
    
    *   Create feature branches
    *   Follow conventional commits
    *   Keep PRs focused

### Character Development[​](#character-development "Direct link to Character Development")

    # Generate character from Twitter datanpx tweets2character# Convert documents to knowledge basenpx folder2knowledge <path/to/folder># Add knowledge to characternpx knowledge2character <character-file> <knowledge-file>

### Development Scripts[​](#development-scripts "Direct link to Development Scripts")

    # Analyze codebase./scripts/analyze-codebase.ts# Extract tweets for training./scripts/extracttweets.js# Clean build artifacts./scripts/clean.sh

Further Resources[​](#further-resources "Direct link to Further Resources")
---------------------------------------------------------------------------

*   [Configuration Guide](https://elizaos.github.io/eliza/docs/guides/configuration/) for setup details
*   [Advanced Usage](https://elizaos.github.io/eliza/docs/guides/advanced/) for complex features
*   [API Documentation](https://elizaos.github.io/eliza/api/) for complete API reference
*   [Contributing Guide](https://elizaos.github.io/eliza/docs/contributing/) for contribution guidelines</content>
</page>

<page>
  <title>📈 Autonomous Trading | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/advanced/autonomous-trading/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

Eliza's autonomous trading system enables automated token trading on the Solana blockchain. The system integrates with Jupiter aggregator for efficient swaps, implements smart order routing, and includes risk management features.

Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

### Token Provider[​](#token-provider "Direct link to Token Provider")

Manages token information and market data:

    class TokenProvider {  constructor(    private tokenAddress: string,    private walletProvider: WalletProvider,  ) {    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache  }  async fetchPrices(): Promise<Prices> {    const { SOL, BTC, ETH } = TOKEN_ADDRESSES;    // Fetch current prices    return {      solana: { usd: "0" },      bitcoin: { usd: "0" },      ethereum: { usd: "0" },    };  }  async getProcessedTokenData(): Promise<ProcessedTokenData> {    return {      security: await this.fetchTokenSecurity(),      tradeData: await this.fetchTokenTradeData(),      holderDistributionTrend: await this.analyzeHolderDistribution(),      highValueHolders: await this.filterHighValueHolders(),      recentTrades: await this.checkRecentTrades(),      dexScreenerData: await this.fetchDexScreenerData(),    };  }}

### Swap Execution[​](#swap-execution "Direct link to Swap Execution")

Implementation of token swaps using Jupiter:

    async function swapToken(  connection: Connection,  walletPublicKey: PublicKey,  inputTokenCA: string,  outputTokenCA: string,  amount: number,): Promise<any> {  // Get token decimals  const decimals = await getTokenDecimals(connection, inputTokenCA);  const adjustedAmount = amount * 10 ** decimals;  // Fetch quote  const quoteResponse = await fetch(    `https://quote-api.jup.ag/v6/quote?inputMint=${inputTokenCA}` +      `&outputMint=${outputTokenCA}` +      `&amount=${adjustedAmount}` +      `&slippageBps=50`,  );  // Execute swap  const swapResponse = await fetch("https://quote-api.jup.ag/v6/swap", {    method: "POST",    body: JSON.stringify({      quoteResponse: await quoteResponse.json(),      userPublicKey: walletPublicKey.toString(),      wrapAndUnwrapSol: true,    }),  });  return swapResponse.json();}

Position Management[​](#position-management "Direct link to Position Management")
---------------------------------------------------------------------------------

### Order Book System[​](#order-book-system "Direct link to Order Book System")

    interface Order {  userId: string;  ticker: string;  contractAddress: string;  timestamp: string;  buyAmount: number;  price: number;}class OrderBookProvider {  async addOrder(order: Order): Promise<void> {    let orderBook = await this.readOrderBook();    orderBook.push(order);    await this.writeOrderBook(orderBook);  }  async calculateProfitLoss(userId: string): Promise<number> {    const orders = await this.getUserOrders(userId);    return orders.reduce((total, order) => {      const currentPrice = this.getCurrentPrice(order.ticker);      const pl = (currentPrice - order.price) * order.buyAmount;      return total + pl;    }, 0);  }}

### Position Sizing[​](#position-sizing "Direct link to Position Sizing")

    async function calculatePositionSize(  tokenData: ProcessedTokenData,  riskLevel: "LOW" | "MEDIUM" | "HIGH",): Promise<CalculatedBuyAmounts> {  const { liquidity, marketCap } = tokenData.dexScreenerData.pairs[0];  // Impact percentages based on liquidity  const impactPercentages = {    LOW: 0.01, // 1% of liquidity    MEDIUM: 0.05, // 5% of liquidity    HIGH: 0.1, // 10% of liquidity  };  return {    none: 0,    low: liquidity.usd * impactPercentages.LOW,    medium: liquidity.usd * impactPercentages.MEDIUM,    high: liquidity.usd * impactPercentages.HIGH,  };}

Risk Management[​](#risk-management "Direct link to Risk Management")
---------------------------------------------------------------------

### Token Validation[​](#token-validation "Direct link to Token Validation")

    async function validateToken(token: TokenPerformance): Promise<boolean> {  const security = await fetchTokenSecurity(token.tokenAddress);  // Red flags check  if (    security.rugPull ||    security.isScam ||    token.rapidDump ||    token.suspiciousVolume ||    token.liquidity.usd < 1000 || // Minimum $1000 liquidity    token.marketCap < 100000 // Minimum $100k market cap  ) {    return false;  }  // Holder distribution check  const holderData = await fetchHolderList(token.tokenAddress);  const topHolderPercent = calculateTopHolderPercentage(holderData);  if (topHolderPercent > 0.5) {    // >50% held by top holders    return false;  }  return true;}

### Trade Management[​](#trade-management "Direct link to Trade Management")

    interface TradeManager {    async executeTrade(params: {        inputToken: string,        outputToken: string,        amount: number,        slippage: number    }): Promise<string>;    async monitorPosition(params: {        tokenAddress: string,        entryPrice: number,        stopLoss: number,        takeProfit: number    }): Promise<void>;    async closePosition(params: {        tokenAddress: string,        amount: number    }): Promise<string>;}

Market Analysis[​](#market-analysis "Direct link to Market Analysis")
---------------------------------------------------------------------

### Price Data Collection[​](#price-data-collection "Direct link to Price Data Collection")

    async function collectMarketData(  tokenAddress: string,): Promise<TokenTradeData> {  return {    price: await fetchCurrentPrice(tokenAddress),    volume_24h: await fetch24HourVolume(tokenAddress),    price_change_24h: await fetch24HourPriceChange(tokenAddress),    liquidity: await fetchLiquidity(tokenAddress),    holder_data: await fetchHolderData(tokenAddress),    trade_history: await fetchTradeHistory(tokenAddress),  };}

### Technical Analysis[​](#technical-analysis "Direct link to Technical Analysis")

    function analyzeMarketConditions(tradeData: TokenTradeData): MarketAnalysis {  return {    trend: analyzePriceTrend(tradeData.price_history),    volume_profile: analyzeVolumeProfile(tradeData.volume_history),    liquidity_depth: analyzeLiquidityDepth(tradeData.liquidity),    holder_behavior: analyzeHolderBehavior(tradeData.holder_data),  };}

Trade Execution[​](#trade-execution "Direct link to Trade Execution")
---------------------------------------------------------------------

### Swap Implementation[​](#swap-implementation "Direct link to Swap Implementation")

    async function executeSwap(  runtime: IAgentRuntime,  input: {    tokenIn: string;    tokenOut: string;    amountIn: number;    slippage: number;  },): Promise<string> {  // Prepare transaction  const { swapTransaction } = await getSwapTransaction(input);  // Sign transaction  const keypair = getKeypairFromPrivateKey(    runtime.getSetting("SOLANA_PRIVATE_KEY") ??      runtime.getSetting("WALLET_PRIVATE_KEY"),  );  transaction.sign([keypair]);  // Execute swap  const signature = await connection.sendTransaction(transaction);  // Confirm transaction  await connection.confirmTransaction({    signature,    blockhash: latestBlockhash.blockhash,    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight,  });  return signature;}

### DAO Integration[​](#dao-integration "Direct link to DAO Integration")

    async function executeSwapForDAO(  runtime: IAgentRuntime,  params: {    inputToken: string;    outputToken: string;    amount: number;  },): Promise<string> {  const authority = getAuthorityKeypair(runtime);  const [statePDA, walletPDA] = await derivePDAs(authority);  // Prepare instruction data  const instructionData = prepareSwapInstruction(params);  // Execute swap through DAO  return invokeSwapDao(    connection,    authority,    statePDA,    walletPDA,    instructionData,  );}

Monitoring & Safety[​](#monitoring--safety "Direct link to Monitoring & Safety")
--------------------------------------------------------------------------------

### Health Checks[​](#health-checks "Direct link to Health Checks")

    async function performHealthChecks(): Promise<HealthStatus> {  return {    connection: await checkConnectionStatus(),    wallet: await checkWalletBalance(),    orders: await checkOpenOrders(),    positions: await checkPositions(),  };}

### Safety Limits[​](#safety-limits "Direct link to Safety Limits")

    const SAFETY_LIMITS = {  MAX_POSITION_SIZE: 0.1, // 10% of portfolio  MAX_SLIPPAGE: 0.05, // 5% slippage  MIN_LIQUIDITY: 1000, // $1000 minimum liquidity  MAX_PRICE_IMPACT: 0.03, // 3% price impact  STOP_LOSS: 0.15, // 15% stop loss};

Error Handling[​](#error-handling "Direct link to Error Handling")
------------------------------------------------------------------

### Transaction Errors[​](#transaction-errors "Direct link to Transaction Errors")

    async function handleTransactionError(  error: Error,  transaction: Transaction,): Promise<void> {  if (error.message.includes("insufficient funds")) {    await handleInsufficientFunds();  } else if (error.message.includes("slippage tolerance exceeded")) {    await handleSlippageError(transaction);  } else {    await logTransactionError(error, transaction);  }}

### Recovery Procedures[​](#recovery-procedures "Direct link to Recovery Procedures")

    async function recoverFromError(  error: Error,  context: TradingContext,): Promise<void> {  // Stop all active trades  await stopActiveTrades();  // Close risky positions  await closeRiskyPositions();  // Reset system state  await resetTradingState();  // Notify administrators  await notifyAdministrators(error, context);}</content>
</page>

<page>
  <title>🎯 Fine-tuning Guide | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/advanced/fine-tuning/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

Eliza supports multiple AI model providers and offers extensive configuration options for fine-tuning model behavior, embedding generation, and performance optimization.

Model Providers[​](#model-providers "Direct link to Model Providers")
---------------------------------------------------------------------

Eliza supports multiple model providers through a flexible configuration system:

    enum ModelProviderName {  OPENAI,  ANTHROPIC,  CLAUDE_VERTEX,  GROK,  GROQ,  LLAMACLOUD,  LLAMALOCAL,  GOOGLE,  REDPILL,  OPENROUTER,  HEURIST,}

### Provider Configuration[​](#provider-configuration "Direct link to Provider Configuration")

Each provider has specific settings:

    const models = {  [ModelProviderName.ANTHROPIC]: {    settings: {      stop: [],      maxInputTokens: 200000,      maxOutputTokens: 8192,      frequency_penalty: 0.0,      presence_penalty: 0.0,      temperature: 0.3,    },    endpoint: "https://api.anthropic.com/v1",    model: {      [ModelClass.SMALL]: "claude-3-5-haiku",      [ModelClass.MEDIUM]: "claude-3-5-sonnet-20241022",      [ModelClass.LARGE]: "claude-3-5-opus-20240229",    },  },  // ... other providers};

Model Classes[​](#model-classes "Direct link to Model Classes")
---------------------------------------------------------------

Models are categorized into different classes based on their capabilities:

    enum ModelClass {    SMALL,     // Fast, efficient for simple tasks    MEDIUM,    // Balanced performance and capability    LARGE,     // Most capable but slower/more expensive    EMBEDDING, // Specialized for vector embeddings    IMAGE      // Image generation capabilities}

Embedding System[​](#embedding-system "Direct link to Embedding System")
------------------------------------------------------------------------

### Configuration[​](#configuration "Direct link to Configuration")

    const embeddingConfig = {  dimensions: 1536,  modelName: "text-embedding-3-small",  cacheEnabled: true,};

### Implementation[​](#implementation "Direct link to Implementation")

    async function embed(runtime: IAgentRuntime, input: string): Promise<number[]> {  // Check cache first  const cachedEmbedding = await retrieveCachedEmbedding(runtime, input);  if (cachedEmbedding) return cachedEmbedding;  // Generate new embedding  const response = await runtime.fetch(    `${runtime.modelProvider.endpoint}/embeddings`,    {      method: "POST",      headers: {        Authorization: `Bearer ${runtime.token}`,        "Content-Type": "application/json",      },      body: JSON.stringify({        input,        model: runtime.modelProvider.model.EMBEDDING,        dimensions: 1536,      }),    },  );  const data = await response.json();  return data?.data?.[0].embedding;}

Fine-tuning Options[​](#fine-tuning-options "Direct link to Fine-tuning Options")
---------------------------------------------------------------------------------

### Temperature Control[​](#temperature-control "Direct link to Temperature Control")

Configure model creativity vs. determinism:

    const temperatureSettings = {  creative: {    temperature: 0.8,    frequency_penalty: 0.7,    presence_penalty: 0.7,  },  balanced: {    temperature: 0.5,    frequency_penalty: 0.3,    presence_penalty: 0.3,  },  precise: {    temperature: 0.2,    frequency_penalty: 0.0,    presence_penalty: 0.0,  },};

### Context Window[​](#context-window "Direct link to Context Window")

Manage token limits:

    const contextSettings = {  OPENAI: {    maxInputTokens: 128000,    maxOutputTokens: 8192,  },  ANTHROPIC: {    maxInputTokens: 200000,    maxOutputTokens: 8192,  },  LLAMALOCAL: {    maxInputTokens: 32768,    maxOutputTokens: 8192,  },};

Performance Optimization[​](#performance-optimization "Direct link to Performance Optimization")
------------------------------------------------------------------------------------------------

### Caching Strategy[​](#caching-strategy "Direct link to Caching Strategy")

    class EmbeddingCache {  private cache: NodeCache;  private cacheDir: string;  constructor() {    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minute TTL    this.cacheDir = path.join(__dirname, "cache");  }  async get(key: string): Promise<number[] | null> {    // Check memory cache first    const cached = this.cache.get<number[]>(key);    if (cached) return cached;    // Check disk cache    return this.readFromDisk(key);  }  async set(key: string, embedding: number[]): Promise<void> {    this.cache.set(key, embedding);    await this.writeToDisk(key, embedding);  }}

### Model Selection[​](#model-selection "Direct link to Model Selection")

    async function selectOptimalModel(  task: string,  requirements: ModelRequirements,): Promise<ModelClass> {  if (requirements.speed === "fast") {    return ModelClass.SMALL;  } else if (requirements.complexity === "high") {    return ModelClass.LARGE;  }  return ModelClass.MEDIUM;}

Provider-Specific Optimizations[​](#provider-specific-optimizations "Direct link to Provider-Specific Optimizations")
---------------------------------------------------------------------------------------------------------------------

### OpenAI[​](#openai "Direct link to OpenAI")

    const openAISettings = {  endpoint: "https://api.openai.com/v1",  settings: {    stop: [],    maxInputTokens: 128000,    maxOutputTokens: 8192,    frequency_penalty: 0.0,    presence_penalty: 0.0,    temperature: 0.6,  },  model: {    [ModelClass.SMALL]: "gpt-4o-mini",    [ModelClass.MEDIUM]: "gpt-4o",    [ModelClass.LARGE]: "gpt-4o",    [ModelClass.EMBEDDING]: "text-embedding-3-small",    [ModelClass.IMAGE]: "dall-e-3",  },};

### Anthropic[​](#anthropic "Direct link to Anthropic")

    const anthropicSettings = {  endpoint: "https://api.anthropic.com/v1",  settings: {    stop: [],    maxInputTokens: 200000,    maxOutputTokens: 8192,    temperature: 0.3,  },  model: {    [ModelClass.SMALL]: "claude-3-5-haiku",    [ModelClass.MEDIUM]: "claude-3-5-sonnet-20241022",    [ModelClass.LARGE]: "claude-3-5-opus-20240229",  },};

### Local LLM[​](#local-llm "Direct link to Local LLM")

    const llamaLocalSettings = {  settings: {    stop: ["<|eot_id|>", "<|eom_id|>"],    maxInputTokens: 32768,    maxOutputTokens: 8192,    repetition_penalty: 0.0,    temperature: 0.3,  },  model: {    [ModelClass.SMALL]: "NousResearch/Hermes-3-Llama-3.1-8B-GGUF",    [ModelClass.MEDIUM]: "NousResearch/Hermes-3-Llama-3.1-8B-GGUF",    [ModelClass.LARGE]: "NousResearch/Hermes-3-Llama-3.1-8B-GGUF",    [ModelClass.EMBEDDING]: "togethercomputer/m2-bert-80M-32k-retrieval",  },};

### Heurist Provider[​](#heurist-provider "Direct link to Heurist Provider")

    const heuristSettings = {  settings: {    stop: [],    maxInputTokens: 32768,    maxOutputTokens: 8192,    repetition_penalty: 0.0,    temperature: 0.7,  },  imageSettings: {    steps: 20,  },  endpoint: "https://llm-gateway.heurist.xyz",  model: {    [ModelClass.SMALL]: "hermes-3-llama3.1-8b",    [ModelClass.MEDIUM]: "mistralai/mixtral-8x7b-instruct",    [ModelClass.LARGE]: "nvidia/llama-3.1-nemotron-70b-instruct",    [ModelClass.EMBEDDING]: "", // Add later    [ModelClass.IMAGE]: "FLUX.1-dev",  },};

Testing and Validation[​](#testing-and-validation "Direct link to Testing and Validation")
------------------------------------------------------------------------------------------

### Embedding Tests[​](#embedding-tests "Direct link to Embedding Tests")

    async function validateEmbedding(  embedding: number[],  expectedDimensions: number = 1536,): Promise<boolean> {  if (!Array.isArray(embedding)) return false;  if (embedding.length !== expectedDimensions) return false;  if (embedding.some((n) => typeof n !== "number")) return false;  return true;}

### Model Performance Testing[​](#model-performance-testing "Direct link to Model Performance Testing")

    async function benchmarkModel(  runtime: IAgentRuntime,  modelClass: ModelClass,  testCases: TestCase[],): Promise<BenchmarkResults> {  const results = {    latency: [],    tokenUsage: [],    accuracy: [],  };  for (const test of testCases) {    const start = Date.now();    const response = await runtime.generateText({      context: test.input,      modelClass,    });    results.latency.push(Date.now() - start);    // ... additional metrics  }  return results;}

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### Model Selection Guidelines[​](#model-selection-guidelines "Direct link to Model Selection Guidelines")

1.  **Task Complexity**
    
    *   Use SMALL for simple, quick responses
    *   Use MEDIUM for balanced performance
    *   Use LARGE for complex reasoning
2.  **Context Management**
    
    *   Keep prompts concise and focused
    *   Use context windows efficiently
    *   Implement proper context truncation
3.  **Temperature Adjustment**
    
    *   Lower for factual responses
    *   Higher for creative tasks
    *   Balance based on use case

### Performance Optimization[​](#performance-optimization-1 "Direct link to Performance Optimization")

1.  **Caching Strategy**
    
    *   Cache embeddings for frequently accessed content
    *   Implement tiered caching (memory/disk)
    *   Regular cache cleanup
2.  **Resource Management**
    
    *   Monitor token usage
    *   Implement rate limiting
    *   Optimize batch processing

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  **Token Limits**
    
        function handleTokenLimit(error: Error) {  if (error.message.includes("token limit")) {    return truncateAndRetry();  }}
    
2.  **Embedding Errors**
    
        function handleEmbeddingError(error: Error) {  if (error.message.includes("dimension mismatch")) {    return regenerateEmbedding();  }}
    
3.  **Model Availability**
    
        async function handleModelFailover(error: Error) {  if (error.message.includes("model not available")) {    return switchToFallbackModel();  }}</content>
</page>

<page>
  <title>🫖 Eliza in TEE | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/advanced/eliza-in-tee/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

The Eliza agent can be deployed in a TEE environment to ensure the security and privacy of the agent's data. This guide will walk you through the process of setting up and running an Eliza agent in a TEE environment by utilizing the TEE Plugin in the Eliza Framework.

### Background[​](#background "Direct link to Background")

The TEE Plugin in the Eliza Framework is built on top of the [Dstack SDK](https://github.com/Dstack-TEE/dstack), which is designed to simplify the steps for developers to deploy programs to CVM (Confidential VM), and to follow the security best practices by default. The main features include:

*   Convert any docker container to a CVM image to deploy on supported TEEs
*   Remote Attestation API and a chain-of-trust visualization on Web UI
*   Automatic RA-HTTPS wrapping with content addressing domain on 0xABCD.dstack.host
*   Decouple the app execution and state persistent from specific hardware with decentralized Root-of-Trust

* * *

Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

Eliza's TEE implementation consists of two primary providers that handle secure key management operations and remote attestations.

These components work together to provide:

1.  Secure key derivation within the TEE
2.  Verifiable proof of TEE execution
3.  Support for both development (simulator) and production environments

The providers are typically used together, as seen in the wallet key derivation process where each derived key includes an attestation quote to prove it was generated within the TEE environment.

* * *

### Derive Key Provider[​](#derive-key-provider "Direct link to Derive Key Provider")

The DeriveKeyProvider enables secure key derivation within TEE environments. It supports:

*   Multiple TEE modes:
    *   `LOCAL`: Connects to simulator at `localhost:8090` for local development on Mac/Windows
    *   `DOCKER`: Connects to simulator via `host.docker.internal:8090` for local development on Linux
    *   `PRODUCTION`: Connects to actual TEE environment when deployed to the [TEE Cloud](https://teehouse.vercel.app/)

Key features:

*   Support to deriveEd25519 (Solana) and ECDSA (EVM) keypairs
*   Generates deterministic keys based on a secret salt and agent ID
*   Includes remote attestation for each derived key
*   Supports raw key derivation for custom use cases

Example usage:

    const provider = new DeriveKeyProvider(teeMode);// For Solanaconst { keypair, attestation } = await provider.deriveEd25519Keypair(    "/",    secretSalt,    agentId,);// For EVMconst { keypair, attestation } = await provider.deriveEcdsaKeypair(    "/",    secretSalt,    agentId,);

* * *

### Remote Attestation Provider[​](#remote-attestation-provider "Direct link to Remote Attestation Provider")

The RemoteAttestationProvider handles TEE environment verification and quote generation. It:

*   Connects to the same TEE modes as DeriveKeyProvider
*   Generates TDX quotes with replay protection (RTMRs)
*   Provides attestation data that can be verified by third parties

Key features:

*   Generates attestation quotes with custom report data
*   Includes timestamp for quote verification
*   Supports both simulator and production environments

Example usage:

    const provider = new RemoteAttestationProvider(teeMode);const quote = await provider.generateAttestation(reportData);

Tutorial[​](#tutorial "Direct link to Tutorial")
------------------------------------------------

* * *

### Prerequisites[​](#prerequisites "Direct link to Prerequisites")

Before getting started with Eliza, ensure you have:

*   [Docker Desktop](https://www.docker.com/products/docker-desktop/) or [Orbstack](https://orbstack.dev/) (Orbstack is recommended)
*   For Mac/Windows: Check the prerequisites from [Quickstart Guide](https://elizaos.github.io/eliza/docs/quickstart/)
*   For Linux: You just need Docker

* * *

### Environment Setup[​](#environment-setup "Direct link to Environment Setup")

To set up your environment for TEE development:

1.  **Configure TEE Mode**
    
    Set the `TEE_MODE` environment variable to one of:
    
        # For Mac/Windows local developmentTEE_MODE=LOCAL# For Linux/Docker local developmentTEE_MODE=DOCKER# For production deploymentTEE_MODE=PRODUCTION
    
2.  **Set Required Environment Variables**
    
        # Required for key derivationWALLET_SECRET_SALT=your_secret_salt
    
3.  **Start the TEE Simulator**
    
        docker pull phalanetwork/tappd-simulator:latest# by default the simulator is available in localhost:8090docker run --rm -p 8090:8090 phalanetwork/tappd-simulator:latest
    

### Run an Eliza Agent Locally with TEE Simulator[​](#run-an-eliza-agent-locally-with-tee-simulator "Direct link to Run an Eliza Agent Locally with TEE Simulator")

1.  **Configure Eliza Agent**
    
    Go through the [configuration guide](https://elizaos.github.io/eliza/docs/guides/configuration/) to set up your Eliza agent.
    
2.  **Start the TEE Simulator** Follow the simulator setup instructions above based on your TEE mode.
    
3.  **For Mac/Windows**
    
    Make sure to set the `TEE_MODE` environment variable to `LOCAL`. Then you can install the dependencies and run the agent locally:
    
        pnpm ipnpm buildpnpm start --character=./characters/yourcharacter.character.json
    
4.  **Verify TEE Attestation**
    
    You can verify the TEE attestation quote by going to the [TEE RA Explorer](https://ra-quote-explorer.vercel.app/) and pasting the attestation quote from the agent logs. Here's an example of interacting with the Eliza agent to ask for the agent's wallet address:
    
        You: what's your wallet address?
    
    Log output from the agent:
    
        Generating attestation for:  {"agentId":"025e0996-69d7-0dce-8189-390e354fd1c1","publicKey":"9yZBmCRRFEBtA3KYokxC24igv1ijFp6tyvzKxRs3khTE"}rtmr0: a4a17452e7868f62f77ea2039bd2840e7611a928c26e87541481256f57bfbe3647f596abf6e8f6b5a0e7108acccc6e89rtmr1: db6bcc74a3ac251a6398eca56b2fcdc8c00a9a0b36bc6299e06fb4bb766cb9ecc96de7e367c56032c7feff586f9e557ertmr2: 2cbe156e110b0cc4b2418600dfa9fb33fc60b3f04b794ec1b8d154b48f07ba8c001cd31f75ca0d0fb516016552500d07rtmr3: eb7110de9956d7b4b1a3397f843b39d92df4caac263f5083e34e3161e4d6686c46c3239e7fbf61241a159d8da6dc6bd1fRemote attestation quote:  {quote: '0x0400030081000000736940f888442c8ca8cb432d7a87145f9b7aeab1c5d129ce901716a7506375426ea8741ca69be68e92c5df29f539f103eb60ab6780c56953b0d81af523a031617b32d5e8436cceb019177103f4aceedbf114a846baf8e8e2b8e6d3956e96d6b89d94a0f1a366e6c309d77c77c095a13d2d5e2f8e2d7f51ece4ae5ffc5fe8683a37387bfdb9acb8528f37342360abb64ec05ff438f7e4fad73c69a627de245a31168f69823883ed8ba590c454914690946b7b07918ded5b89dc663c70941f8704978b91a24b54d88038c30d20d14d85016a524f7176c7a7cff7233a2a4405da9c31c8569ac3adfe5147bdb92faee0f075b36e8ce794aaf596facd881588167fbcf5a7d059474c1e4abff645bba8a813f3083c5a425fcc88cd706b19494dedc04be2bc3ab1d71b2a062ddf62d0393d8cb421393cccc932a19d43e315a18a10d216aea4a1752cf3f3b0b2fb36bea655822e2b27c6156970d18e345930a4a589e1850fe84277e0913ad863dffb1950fbeb03a4a17452e7868f62f77ea2039bd2840e7611a928c26e87541481256f57bfbe3647f596abf6e8f6b5a0e7108acccc6e89db6bcc74a3ac251a6398eca56b2fcdc8c00a9a0b36bc6299e06fb4bb766cb9ecc96de7e367c56032c7feff586f9e557e2cbe156e110b0cc4b2418600dfa9fb33fc60b3f04b794ec1b8d154b48f07ba8c001cd31f75ca0d0fb516016552500d07eb7110de9956d7b4b1a3397f843b39d92df4caac263f5083e34e3161e4d6686c46c3239e7fbf61241a159d8da6dc6bd13df734883d4d0d78d670a1d17e28ef09dffbbfbd15063b73113cb5bed692d68cc30c38cb9389403fe6a1c32c35dbac75464b77597e27b854839db51dfde0885462020000530678b9eb99d1b9e08a6231ef00055560f7d3345f54ce355da68725bb38cab0caf84757ddb93db87577758bb06de7923c4ee3583453f284c8b377a1ec2ef613491e051c801a63da5cb42b9c12e26679fcf489f3b14bd5e8f551227b09d976975e0fbd68dcdf129110a5ca8ed8d163dafb60e1ec4831d5285a7fbae81d0e39580000dc010000ebb282d5c6aca9053a21814e9d65a1516ebeaacf6fc88503e794d75cfc5682e86aa04e9d6e58346e013c5c1203afc5c72861e2a7052afcdcb3ddcccd102dd0daeb595968edb6a6c513db8e2155fc302eeca7a34c9ba81289d6941c4c813db9bf7bd0981d188ab131e5ae9c4bb831e4243b20edb7829a6a7a9cf0eae1214b450109d990e2c824c2a60a47faf90c24992583bc5c3da3b58bd8830a4f0ad5c650aa08ae0e067d4251d251e56d70972ad901038082ee9340f103fd687ec7d91a9b8b8652b1a2b7befb4cbfdb6863f00142e0b2e67198ddc8ddbe96dc02762d935594394f173114215cb5abcf55b9815eb545683528c990bfae34c34358dbb19dfc1426f56cba12af325d7a2941c0d45d0ea4334155b790554d3829e3be618eb1bfc6f3a06f488bbeb910b33533c6741bff6c8a0ca43eb2417eec5ecc2f50f65c3b40d26174376202915337c7992cdd44471dee7a7b2038605415a7af593fd9066661e594b26f4298baf6d001906aa8fc1c460966fbc17b2c35e0973f613399936173802cf0453a4e7d8487b6113a77947eef190ea8d47ba531ce51abf5166448c24a54de09d671fd57cbd68154f5995aee6c2ccfd6738387cf3ad9f0ad5e8c7d46fb0a0000000000000000000000bd920a00000000000000000000000000',timestamp: 1733606453433}
    
    Take the `quote` field and paste it into the [TEE RA Explorer](https://ra-quote-explorer.vercel.app/) to verify the attestation. **Note**: The verification will be unverified since the quote is generated from the TEE simulator.
    

### Build, Test, and Publish an Eliza Agent Docker Image[​](#build-test-and-publish-an-eliza-agent-docker-image "Direct link to Build, Test, and Publish an Eliza Agent Docker Image")

Now that we have run the Eliza agent in the TEE simulator, we can build and publish an Eliza agent Docker image to prepare for deployment to a real TEE environment.

First, you need to create a Docker account and publish your image to a container registry. Here we will use [Docker Hub](https://hub.docker.com/) as an example.

Login to Docker Hub:

Build the Docker image:

    # For Linux/AMD64 machines rundocker build -t username/eliza-agent:latest .# For architecture other than AMD64, rundocker buildx build --platform=linux/amd64 -t username/eliza-agent:latest .

For Linux/AMD64 machines, you can now test the agent locally by updating the `TEE_MODE` environment variable to `DOCKER` and setting the environment variables in the [docker-compose.yaml](https://github.com/elizaos/eliza/blob/main/docker-compose.yaml) file. Once you have done that, you can start the agent by running:

> **Note**: Make sure the TEE simulator is running before starting the agent through docker compose.

Publish the Docker image to a container registry:

    docker push username/eliza-agent:latest

Now we are ready to deploy the Eliza agent to a real TEE environment.

### Run an Eliza Agent in a Real TEE Environment[​](#run-an-eliza-agent-in-a-real-tee-environment "Direct link to Run an Eliza Agent in a Real TEE Environment")

Before deploying the Eliza agent to a real TEE environment, you need to create a new TEE account on the [TEE Cloud](https://teehouse.vercel.app/). Reach out to Phala Network on [Discord](https://discord.gg/phalanetwork) if you need help.

Next, you will need to take the docker-compose.yaml file in the root folder of the project and edit it based on your agent configuration.

> **Note**: The API Keys and other secret environment variables should be set in your secret environment variables configuration in the TEE Cloud dashboard.

    # docker-compose.yamlservices:    tee:        command:            [                "pnpm",                "start",                "--character=./characters/yourcharacter.character.json",            ]        image: username/eliza-agent:latest        stdin_open: true        tty: true        volumes:            - /var/run/tappd.sock:/var/run/tappd.sock            - tee:/app/packages/client-twitter/src/tweetcache            - tee:/app/db.sqlite        environment:            - REDPILL_API_KEY=$REDPILL_API_KEY            - SMALL_REDPILL_MODEL=anthropic/claude-3-5-sonnet            - MEDIUM_REDPILL_MODEL=anthropic/claude-3-5-sonnet            - LARGE_REDPILL_MODEL=anthropic/claude-3-opus            - ELEVENLABS_XI_API_KEY=$ELEVENLABS_XI_API_KEY            - ELEVENLABS_MODEL_ID=eleven_multilingual_v2            - ELEVENLABS_VOICE_ID=21m00Tcm4TlvDq8ikWAM            - ELEVENLABS_VOICE_STABILITY=0.5            - ELEVENLABS_VOICE_SIMILARITY_BOOST=0.9            - ELEVENLABS_VOICE_STYLE=0.66            - ELEVENLABS_VOICE_USE_SPEAKER_BOOST=false            - ELEVENLABS_OPTIMIZE_STREAMING_LATENCY=4            - ELEVENLABS_OUTPUT_FORMAT=pcm_16000            - TWITTER_DRY_RUN=false            - TWITTER_USERNAME=$TWITTER_USERNAME            - TWITTER_PASSWORD=$TWITTER_PASSWORD            - TWITTER_EMAIL=$TWITTER_EMAIL            - X_SERVER_URL=$X_SERVER_URL            - BIRDEYE_API_KEY=$BIRDEYE_API_KEY            - SOL_ADDRESS=So11111111111111111111111111111111111111112            - SLIPPAGE=1            - RPC_URL=https://api.mainnet-beta.solana.com            - HELIUS_API_KEY=$HELIUS_API_KEY            - SERVER_PORT=3000            - WALLET_SECRET_SALT=$WALLET_SECRET_SALT            - TEE_MODE=PRODUCTION        ports:            - "3000:80"        restart: alwaysvolumes:    tee:

Now you can deploy the Eliza agent to a real TEE environment. Go to the [TEE Cloud](https://teehouse.vercel.app/) and click on the `Create VM` button to configure your Eliza agent deployment.

Click on the `Compose Manifest Mode` tab and paste the docker-compose.yaml file content into the `Compose Manifest` field.

Next, go to the `Resources` tab and configure your VM resources.

> **Note**: The `CPU` and `Memory` resources should be greater than the minimum requirements for your agent configuration (Recommended: 2 CPU, 4GB Memory, 50GB Disk).

Finally, click on the `Submit` button to deploy your Eliza agent.

This will take a few minutes to complete. Once the deployment is complete, you can click on the `View` button to view your Eliza agent.

Here is an example of a deployed agent named `vitailik2077`:

I can go to the dashboard and view the remote attestation info:

Click on the `Logs` tab to view the agent logs.

Now we can verify the REAL TEE attestation quote by going to the [TEE RA Explorer](https://ra-quote-explorer.vercel.app/) and pasting the attestation quote from the agent logs.

Congratulations! You have successfully run an Eliza agent in a real TEE environment.</content>
</page>

<page>
  <title>Creator Fund | eliza</title>
  <url>https://elizaos.github.io/eliza/community/creator-fund/</url>
  <content>*   [](https://elizaos.github.io/eliza/)
*   Creator Fund

The Creator Fund
----------------

The Creator Fund is an initiative designed to support and empower developers, creators, and community members who are building the future of autonomous AI agents.

The Story Behind the Fund[​](#the-story-behind-the-fund "Direct link to The Story Behind the Fund")
---------------------------------------------------------------------------------------------------

Here's when the community learned about who the top holder is:

**The Donation**

> "So a ton of people have been asking (justifiably) who the heck I am, why do I have 16% of ai16z supply, and what I’m going to do with it.
> 
> It started by @shawmakesmagic tweeting about some agent he built called @degenspartanai, a recreation of a legend on twitter. I put a bunch of my SOL in there because I had been following Shaw and really thought he was building something great. Almost immediately all of that became close to worthless. Degen’s tweets seemed too “human-like” to be real anyway - so I figured I got scammed.
> 
> So I DM’ed shaw, not because I was angry, but I was genuinely curious why he might have scammed me. I ended up sending him a google meet, which turned into an hour long conversation about what he was actually building, and me realizing twitter is usually a misrepresentation of the people you think you know. Shaw is just inspiring. Someone who is completely dedicated to accelerating the world for the better, and not optimizing for optics or money - just building.
> 
> I put back the remaining SOL I had sold and kept supporting Shaw in anyway I could. He was really busy so I just stuck around in his discord. (We also did a twitter spaces if you're interested: [https://x.com/shawmakesmagic/status/1848553697611301014](https://x.com/shawmakesmagic/status/1848553697611301014)). I was in awe, especially in a space filled with Larps and chatgpt copy/pasters.
> 
> When he launched ai16z I didn’t even flinch. I had 80 SOL in my wallet and just pressed buy. It resulted in me owning 17% of it, which I didn't even want. I immediately sent Shaw and another team member some coins because they didn’t even get a chance themselves to buy any! I also sent some of my friends some coins at a discount so they could hopefully benefit as well.
> 
> As for the remaining of my 16%, im lowering it to 5% and donating the remaining 11% to a new ai16z initiative. A locked fund that vests over time to support promising developers and creators, and helps solve liquidity issues via potential OTC deals that benefit the DAO and bring in new partners. This story isn't about me, its about the amazing things this community is building.
> 
> Accelerate.
> 
> *   Elijah (Gigachad) [https://x.com/elijah10T/status/1850964696473465124](https://x.com/elijah10T/status/1850964696473465124)

The donated funds will be held in a dedicated wallet (`9YnQdCWDAQRfQYm5HvRzoPgc5GRn8fyhsH2eru8nfsxG`) and distributed via Streamflow token vesting contracts. This approach ensures that creators receive a steady stream of ai16z tokens over time as they hit milestones and deliver value to the ecosystem.

Benefits and Vision[​](#benefits-and-vision "Direct link to Benefits and Vision")
---------------------------------------------------------------------------------

The Creator Fund aims to:

*   Bootstrap and reward an ecosystem of innovative creators building on elizaos
*   Give creators the runway to focus on their work without worrying about short-term token prices
*   Put Elijah's tokens to productive use in growing the community, rather than through a one-time event
*   Reduce the risk of token dumping by aligning creators' interests with the long-term success of the project
*   Bring more talent and energy into the ecosystem to drive innovation and adoption

By providing ongoing sponsorship and recognizing creators' efforts, the fund will help cultivate a thriving community of builders who will take ai16z / eliza framework to the next level.

Next Steps[​](#next-steps "Direct link to Next Steps")
------------------------------------------------------

We are currently working on finalizing the details of the Creator Fund, including:

*   Determining the size of the creator fund and the length of vesting schedules
*   Establishing a transparent creator grant application and selection process
*   Integrating Streamflow to manage token vesting contracts for selected grantees
*   Preparing to announce the first cohort of funded creators and share their exciting projects with the community

Stay tuned for more information on how to apply for grants from the Creator Fund. In the meantime, creators and developers are encouraged to start brainstorming ideas and preparing their applications.

A Note on Liquidity[​](#a-note-on-liquidity "Direct link to A Note on Liquidity")
---------------------------------------------------------------------------------

In addition to the Creator Fund, we are also exploring OTC (over-the-counter) deals to onboard new partners and use the funds to lock in more liquidity for the ecosystem. This approach will help ensure a healthy and sustainable token economy as we continue to grow and evolve.

[](https://elizaos.github.io/eliza/community/)[](https://elizaos.github.io/eliza/community/faq-and-support/)

*   [The Story Behind the Fund](#the-story-behind-the-fund)
*   [Benefits and Vision](#benefits-and-vision)
*   [Next Steps](#next-steps)
*   [A Note on Liquidity](#a-note-on-liquidity)</content>
</page>

<page>
  <title>🤝 Trust Engine | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/advanced/trust-engine/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

The Trust Engine is a sophisticated system for evaluating, tracking, and managing trust scores for token recommendations and trading activity. It combines on-chain analysis, trader metrics, and historical performance to create a comprehensive trust framework.

Core Components[​](#core-components "Direct link to Core Components")
---------------------------------------------------------------------

### Trust Score Database[​](#trust-score-database "Direct link to Trust Score Database")

The database schema manages various aspects of trust:

    interface TrustScoreDatabase {  // Core data structures  recommenders: Recommender[];  metrics: RecommenderMetrics[];  tokenPerformance: TokenPerformance[];  recommendations: TokenRecommendation[];}interface Recommender {  id: string;  address: string;  solanaPubkey?: string;  telegramId?: string;  discordId?: string;  twitterId?: string;  ip?: string;}interface RecommenderMetrics {  recommenderId: string;  trustScore: number;  totalRecommendations: number;  successfulRecs: number;  avgTokenPerformance: number;  riskScore: number;  consistencyScore: number;  virtualConfidence: number;  lastActiveDate: Date;}

### Token Analysis[​](#token-analysis "Direct link to Token Analysis")

The system tracks comprehensive token metrics:

    interface TokenPerformance {  tokenAddress: string;  priceChange24h: number;  volumeChange24h: number;  trade_24h_change: number;  liquidity: number;  liquidityChange24h: number;  holderChange24h: number;  rugPull: boolean;  isScam: boolean;  marketCapChange24h: number;  sustainedGrowth: boolean;  rapidDump: boolean;  suspiciousVolume: boolean;  validationTrust: number;  lastUpdated: Date;}

Trust Scoring System[​](#trust-scoring-system "Direct link to Trust Scoring System")
------------------------------------------------------------------------------------

### Score Calculation[​](#score-calculation "Direct link to Score Calculation")

    async function calculateTrustScore(  recommenderId: string,  metrics: RecommenderMetrics,): Promise<number> {  const weights = {    successRate: 0.3,    avgPerformance: 0.2,    consistency: 0.2,    riskMetric: 0.15,    timeDecay: 0.15,  };  const successRate = metrics.successfulRecs / metrics.totalRecommendations;  const normalizedPerformance = normalizePerformance(    metrics.avgTokenPerformance,  );  const timeDecayFactor = calculateTimeDecay(metrics.lastActiveDate);  return (    (successRate * weights.successRate +      normalizedPerformance * weights.avgPerformance +      metrics.consistencyScore * weights.consistency +      (1 - metrics.riskScore) * weights.riskMetric +      timeDecayFactor * weights.timeDecay) *    100  );}

### Token Validation[​](#token-validation "Direct link to Token Validation")

    async function validateToken(  tokenAddress: string,  performance: TokenPerformance,): Promise<boolean> {  // Minimum requirements  const requirements = {    minLiquidity: 1000, // $1000 USD    minHolders: 100,    maxOwnership: 0.2, // 20% max single holder    minVolume: 500, // $500 USD daily volume  };  // Red flags  if (    performance.rugPull ||    performance.isScam ||    performance.rapidDump ||    performance.suspiciousVolume  ) {    return false;  }  // Basic requirements  return (    performance.liquidity >= requirements.minLiquidity &&    !performance.rapidDump &&    performance.validationTrust > 0.5  );}

Trade Management[​](#trade-management "Direct link to Trade Management")
------------------------------------------------------------------------

### Trade Performance Tracking[​](#trade-performance-tracking "Direct link to Trade Performance Tracking")

    interface TradePerformance {  token_address: string;  recommender_id: string;  buy_price: number;  sell_price: number;  buy_timeStamp: string;  sell_timeStamp: string;  profit_usd: number;  profit_percent: number;  market_cap_change: number;  liquidity_change: number;  rapidDump: boolean;}async function recordTradePerformance(  trade: TradePerformance,  isSimulation: boolean,): Promise<void> {  const tableName = isSimulation ? "simulation_trade" : "trade";  await db.query(    `        INSERT INTO ${tableName} (            token_address,            recommender_id,            buy_price,            sell_price,            buy_timeStamp,            sell_timeStamp,            profit_usd,            profit_percent,            market_cap_change,            liquidity_change,            rapidDump        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)    `,    [      /* parameters */    ],  );}

### Risk Management[​](#risk-management "Direct link to Risk Management")

    async function assessTradeRisk(  token: TokenPerformance,  recommender: RecommenderMetrics,): Promise<{  riskLevel: "LOW" | "MEDIUM" | "HIGH";  maxPositionSize: number;}> {  const riskFactors = {    tokenTrust: token.validationTrust,    recommenderTrust: recommender.trustScore,    marketMetrics: {      liquidity: token.liquidity,      volume: token.volumeChange24h,      holders: token.holderChange24h,    },  };  // Calculate composite risk score  const riskScore = calculateRiskScore(riskFactors);  // Determine position sizing  const maxPosition = determinePositionSize(riskScore);  return {    riskLevel: getRiskLevel(riskScore),    maxPositionSize: maxPosition,  };}

Recommendation Analysis[​](#recommendation-analysis "Direct link to Recommendation Analysis")
---------------------------------------------------------------------------------------------

### Pattern Detection[​](#pattern-detection "Direct link to Pattern Detection")

    async function analyzeRecommendationPatterns(  recommenderId: string,): Promise<RecommendationPattern> {  const history = await getRecommenderHistory(recommenderId);  return {    timeOfDay: analyzeTimingPatterns(history),    tokenTypes: analyzeTokenPreferences(history),    successRateByType: calculateTypeSuccessRates(history),    riskProfile: assessRiskProfile(history),  };}

### Performance Metrics[​](#performance-metrics "Direct link to Performance Metrics")

    interface PerformanceMetrics {  profitability: number;  consistency: number;  riskAdjustedReturn: number;  maxDrawdown: number;  winRate: number;}async function calculatePerformanceMetrics(  recommendations: TokenRecommendation[],): Promise<PerformanceMetrics> {  const trades = await getTradesFromRecommendations(recommendations);  return {    profitability: calculateProfitability(trades),    consistency: calculateConsistency(trades),    riskAdjustedReturn: calculateSharpeRatio(trades),    maxDrawdown: calculateMaxDrawdown(trades),    winRate: calculateWinRate(trades),  };}

Integration with Trading System[​](#integration-with-trading-system "Direct link to Integration with Trading System")
---------------------------------------------------------------------------------------------------------------------

### Trade Execution[​](#trade-execution "Direct link to Trade Execution")

    async function executeTrade(  recommendation: TokenRecommendation,  trustScore: number,): Promise<boolean> {  const riskAssessment = await assessTradeRisk(    recommendation.tokenAddress,    recommendation.recommenderId,  );  // Calculate position size based on trust score  const positionSize = calculatePositionSize(    trustScore,    riskAssessment.maxPositionSize,  );  if (positionSize > 0) {    await executeSwap({      inputToken: "SOL",      outputToken: recommendation.tokenAddress,      amount: positionSize,    });    await recordTradeEntry(recommendation, positionSize);    return true;  }  return false;}

### Position Management[​](#position-management "Direct link to Position Management")

    async function managePosition(  position: TradePosition,  metrics: TokenPerformance,): Promise<void> {  // Exit conditions  if (    metrics.rapidDump ||    metrics.suspiciousVolume ||    calculateDrawdown(position) > MAX_DRAWDOWN  ) {    await executeExit(position);    return;  }  // Position sizing adjustments  const newSize = recalculatePosition(position, metrics);  if (newSize !== position.size) {    await adjustPosition(position, newSize);  }}

Monitoring and Alerts[​](#monitoring-and-alerts "Direct link to Monitoring and Alerts")
---------------------------------------------------------------------------------------

### Performance Monitoring[​](#performance-monitoring "Direct link to Performance Monitoring")

    async function monitorTrustMetrics(): Promise<void> {  // Monitor trust score changes  const scoreChanges = await getTrustScoreChanges();  for (const change of scoreChanges) {    if (Math.abs(change.delta) > TRUST_THRESHOLD) {      await notifyTrustChange(change);    }  }  // Monitor trading performance  const performanceMetrics = await getPerformanceMetrics();  for (const metric of performanceMetrics) {    if (metric.drawdown > MAX_DRAWDOWN) {      await notifyRiskAlert(metric);    }  }}

### Alert System[​](#alert-system "Direct link to Alert System")

    interface TrustAlert {  type: "SCORE_CHANGE" | "RISK_LEVEL" | "PERFORMANCE";  severity: "LOW" | "MEDIUM" | "HIGH";  message: string;  data: any;}async function handleAlert(alert: TrustAlert): Promise<void> {  switch (alert.severity) {    case "HIGH":      await sendImmediateNotification(alert);      await pauseTrading(alert.data);      break;    case "MEDIUM":      await sendNotification(alert);      await adjustRiskLevels(alert.data);      break;    case "LOW":      await logAlert(alert);      break;  }}

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  **Trust Score Anomalies**

    async function investigateTrustAnomaly(  recommenderId: string,): Promise<AnomalyReport> {  const history = await getRecommenderHistory(recommenderId);  const metrics = await getRecommenderMetrics(recommenderId);  const trades = await getRecommenderTrades(recommenderId);  return analyzeAnomalies(history, metrics, trades);}

2.  **Trade Execution Failures**

    async function handleTradeFailure(  error: Error,  trade: TradeAttempt,): Promise<void> {  await logTradeError(error, trade);  await adjustTrustScore(trade.recommenderId, "FAILURE");  await notifyTradeFailure(trade);}</content>
</page>

<page>
  <title>🤖 Agent Package | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/packages/agent/</url>
  <content>The Agent Package (`@eliza/agent`) provides the high-level orchestration layer for Eliza, managing agent lifecycles, character loading, client initialization, and runtime coordination.

The Agent Package (`@elizaos/agent`) serves as the orchestration layer for Eliza, handling:

    import { startAgents, loadCharacters } from "@elizaos/agent";// Load characters from filesconst args = parseArguments();const characters = await loadCharacters(args.characters || args.character);// Start agent systemawait startAgents();

    export async function loadCharacters(    charactersArg: string,): Promise<Character[]> {    const characterPaths = normalizeCharacterPaths(charactersArg);    const loadedCharacters = [];    for (const path of characterPaths) {        try {            const character = JSON.parse(fs.readFileSync(path, "utf8"));            // Load plugins if specified            if (character.plugins) {                character.plugins = await Promise.all(                    character.plugins.map(async (plugin) => {                        const importedPlugin = await import(plugin);                        return importedPlugin;                    }),                );            }            loadedCharacters.push(character);        } catch (error) {            console.error(`Error loading character from ${path}: ${error}`);        }    }    // Fall back to default if none loaded    return loadedCharacters.length > 0 ? loadedCharacters : [defaultCharacter];}

    export async function createAgent(    character: Character,    db: IDatabaseAdapter,    token: string,) {    return new AgentRuntime({        databaseAdapter: db,        token,        modelProvider: character.modelProvider,        character,        plugins: [            bootstrapPlugin,            nodePlugin,            character.settings.secrets.WALLET_PUBLIC_KEY ? solanaPlugin : null,        ].filter(Boolean),        providers: [],        actions: [],        services: [],        managers: [],    });}

    export async function initializeClients(    character: Character,    runtime: IAgentRuntime,) {    const clients = [];    const clientTypes =        character.clients?.map((str) => str.toLowerCase()) || [];    if (clientTypes.includes(Clients.DISCORD)) {        clients.push(await DiscordClientInterface.start(runtime));    }    if (clientTypes.includes(Clients.TELEGRAM)) {        clients.push(await TelegramClientInterface.start(runtime));    }    if (clientTypes.includes(Clients.TWITTER)) {        clients.push(await TwitterClientInterface.start(runtime));    }    if (clientTypes.includes(Clients.DIRECT)) {        clients.push(await AutoClientInterface.start(runtime));    }    return clients;}

    export function getTokenForProvider(    provider: ModelProviderName,    character: Character,) {    switch (provider) {        case ModelProviderName.OPENAI:            return (                character.settings?.secrets?.OPENAI_API_KEY ||                settings.OPENAI_API_KEY            );        case ModelProviderName.ANTHROPIC:            return (                character.settings?.secrets?.ANTHROPIC_API_KEY ||                settings.ANTHROPIC_API_KEY            );        // Handle other providers...    }}

    function initializeDatabase() {    if (process.env.POSTGRES_URL) {        return new PostgresDatabaseAdapter({            connectionString: process.env.POSTGRES_URL,        });    }    return new SqliteDatabaseAdapter(new Database("./db.sqlite"));}

    // Handle missing character filesif (!characters || characters.length === 0) {    console.log("No characters found, using default character");    characters = [defaultCharacter];}

    // Handle plugin import errorstry {    character.plugins = await Promise.all(        character.plugins.map((plugin) => import(plugin)),    );} catch (error) {    console.error(`Error loading plugin: ${error.message}`);    character.plugins = [];}</content>
</page>

<page>
  <title>FAQ and Support | eliza</title>
  <url>https://elizaos.github.io/eliza/community/faq-and-support/</url>
  <content>This page provides answers to frequently asked questions about ai16z, the Eliza framework, daos.fun, and how to get support when you need it.

General Questions[​](#general-questions "Direct link to General Questions")
---------------------------------------------------------------------------

### What is ai16z?[​](#what-is-ai16z "Direct link to What is ai16z?")

[ai16z](https://www.daos.fun/HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC) is an AI led fund, fully managed by autonomous investors that take recommendations from members of the DAO. It is a Decentralized Autonomous Organization (DAO) on daos.fun that fosters an open-source community that's building the Eliza framework for creating AI agents.

These are the only official contracts for ai16z:

ai16z: HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC

degenai: Gu3LDkn7Vx3bmCzLafYNKcDxv2mH7YN44NJZFXnypump

Both addresses are pinned here on X and our discord: [https://x.com/ai16zdao/status/1852565056640241793](https://x.com/ai16zdao/status/1852565056640241793)

### Is ai16z affiliated with a16z?[​](#is-ai16z-affiliated-with-a16z "Direct link to Is ai16z affiliated with a16z?")

No, ai16z is not affiliated with Andreessen Horowitz (a16z). The name is a playful reference and parody. There is no affiliation with a16z.

### What is the Eliza framework?[​](#what-is-the-eliza-framework "Direct link to What is the Eliza framework?")

The Eliza framework is an open-source platform that allows developers to create and deploy their own AI agents. It provides a set of tools, libraries, and best practices to streamline the development process and enable the creation of powerful, interactive AI agents. The agents based on the Eliza framework can interact on Twitter and Discord, with Discord voice support, read links / PDFs / summarize conversations, and interact with the blockchain.

### How does daos.fun work?[​](#how-does-daosfun-work "Direct link to How does daos.fun work?")

1.  **Fundraise**: Creators have 1 week to fundraise the desired SOL amount. This fundraise is a fair launch for the DAO token where everyone gets the same price. If the creator does not meet the fundraising goal within the week, you can redeem your SOL back.
2.  **Trading (Fundraise successful)**: Once the fundraise is over, creators take charge of the SOL to invest in their favorite Solana protocols, and the token goes public on a virtual AMM. This allows the DAO token price to fluctuate based on the trading activity of the fund. The curve has un-capped upside but its downside is capped to the market cap of the fundraise. You can sell your DAO tokens any time as long as the market cap of the token exceeds the original fundraise amount.
3.  **Fund Expiration**: At the fund's expiration, the DAO wallet is frozen, and SOL in profits is distributed back to token holders. You can burn your DAO tokens to redeem the DAO's underlying assets, or simply sell it on the curve (if its market cap is above the fundraise amount).

### What is an investment DAO?[​](#what-is-an-investment-dao "Direct link to What is an investment DAO?")

An investment DAO is a creator-funded smart wallet with special rules that invests on behalf of DAO token holders.

### What are verified creators on daos.fun?[​](#what-are-verified-creators-on-daosfun "Direct link to What are verified creators on daos.fun?")

Creators that daos.fun extensively verifies will have a blue checkmark next to them. Any creator without a checkmark you will have to trust at your own risk. DYOR (Do Your Own Research).

### What Happens When Fund Expires?[​](#what-happens-when-fund-expires "Direct link to What Happens When Fund Expires?")

Fund closing does NOT halt trading. Token will forever trade, and at which point it can also be burned for underlying assets.

### Why Dexscreener Show DAO tokens are mintable?[​](#why-dexscreener-show-dao-tokens-are-mintable "Direct link to Why Dexscreener Show DAO tokens are mintable?")

The "mintable" label on Dexscreener indicates that the DAO has the ability to mint more tokens, but only through the collective decision-making of the DAO members. No single person can unilaterally mint more tokens. The voting module for daos.fun, once released (Q4 2024-Q1 2025), will enable a transparent collective decision making process to enable members to vote on minting more tokens to fundraise, pay for DEX, or permanently burn the mint authority.

### Staking and Rewards[​](#staking-and-rewards "Direct link to Staking and Rewards")

daos.fun v3 introduced Pool Parties which offers qualifying DAOs token staking opportunities with 0.5% fees on transactions. The 0.5% fees are auto-compounded into SOL and ai16z (UniswapV2 model). ai16zPOOL LP value volatility is due to token price changes. Fee calculator is coming soon.

### What are ai16z's investment areas?[​](#what-are-ai16zs-investment-areas "Direct link to What are ai16z's investment areas?")

Currently memes.

### How do the autonomous traders make decisions?[​](#how-do-the-autonomous-traders-make-decisions "Direct link to How do the autonomous traders make decisions?")

Token holders above a certain threshold get early access to interact with the autonomous investor to influence his investing decisions. The agent decides how much to trust people's investment advice based on a "Virtual Marketplace of Trust".

First phase where we implement and test functionality is in progress. Second phase where the agents gather data in a testnet environment will run for a couple weeks to gather data, find flaws, test assumptions. Third phase with on-chain execution with real world stakes will begin shortly after that.

Technical Questions[​](#technical-questions "Direct link to Technical Questions")
---------------------------------------------------------------------------------

### What programming languages does Eliza support?[​](#what-programming-languages-does-eliza-support "Direct link to What programming languages does Eliza support?")

The Eliza framework is primarily built using TypeScript, but it also supports JavaScript and Node.js. Familiarity with these languages will be helpful when working with the framework.

### Can I use Eliza to create AI agents for any platform?[​](#can-i-use-eliza-to-create-ai-agents-for-any-platform "Direct link to Can I use Eliza to create AI agents for any platform?")

Yes, Eliza is designed to be platform-agnostic. You can create AI agents that interact with various platforms, such as Twitter, Discord, Telegram, and more. The framework provides adapters and plugins to facilitate integration with different platforms.

### How do I install and set up Eliza?[​](#how-do-i-install-and-set-up-eliza "Direct link to How do I install and set up Eliza?")

Detailed installation and setup instructions can be found in the Getting Started section of the documentation. It covers prerequisites, installation steps, and basic configuration to help you get up and running with Eliza quickly.

Contribution and Support[​](#contribution-and-support "Direct link to Contribution and Support")
------------------------------------------------------------------------------------------------

### How can I contribute to the Eliza framework?[​](#how-can-i-contribute-to-the-eliza-framework "Direct link to How can I contribute to the Eliza framework?")

There are several ways to contribute to the Eliza framework, including:

*   Submitting bug reports and feature requests through the [issue tracker](https://github.com/elizaos/eliza/issues)
*   Fixing bugs, implementing new features, and submitting pull requests on [GitHub](https://github.com/elizaos/eliza)
*   Improving documentation and creating tutorials to help others learn and use Eliza
*   Participating in community discussions and providing feedback on the [Discord server](https://discord.gg/ai16z)

### Where can I find help and support?[​](#where-can-i-find-help-and-support "Direct link to Where can I find help and support?")

If you need help or support, you can:

*   Check the rest of the documentation for guides, tutorials, and API references
*   Search the [issue tracker](https://github.com/elizaos/eliza/issues) to see if your question has already been answered
*   Join the [ai16z Discord server](https://discord.gg/ai16z) and ask for help in the relevant channels

### How can I report a bug or suggest a new feature?[​](#how-can-i-report-a-bug-or-suggest-a-new-feature "Direct link to How can I report a bug or suggest a new feature?")

If you encounter a bug or have a suggestion for a new feature, you can:

1.  Check the [issue tracker](https://github.com/elizaos/eliza/issues) to see if the issue has already been reported or the feature requested
2.  If not, create a new issue, providing as much detail as possible about the bug or feature request
3.  Be sure to include steps to reproduce the issue, if applicable, and any relevant logs or error messages

Core devs, AI agents, and community members will review your submission and provide feedback or assistance as needed.</content>
</page>

<page>
  <title>📦 Core Package | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/packages/core/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

The Core Package (`@elizaos/core`) provides the fundamental building blocks of Eliza's architecture, handling essential functionalities like:

*   Memory Management & Semantic Search
*   Message Processing & Generation
*   Runtime Environment & State Management
*   Action & Evaluator Systems
*   Provider Integration & Context Composition
*   Service Infrastructure

Installation[​](#installation "Direct link to Installation")
------------------------------------------------------------

Key Components[​](#key-components "Direct link to Key Components")
------------------------------------------------------------------

### AgentRuntime[​](#agentruntime "Direct link to AgentRuntime")

The AgentRuntime class serves as the central nervous system of Eliza, orchestrating all major components:

    import { AgentRuntime } from "@elizaos/core";const runtime = new AgentRuntime({    // Core configuration    databaseAdapter,    token,    modelProvider: ModelProviderName.OPENAI,    character,    // Extension points    plugins: [bootstrapPlugin, nodePlugin],    providers: [],    actions: [],    services: [],    managers: [],    // Optional settings    conversationLength: 32,    agentId: customId,    fetch: customFetch,});

Key capabilities:

*   State composition and management
*   Plugin and service registration
*   Memory and relationship management
*   Action processing and evaluation
*   Message generation and handling

### Memory System[​](#memory-system "Direct link to Memory System")

The MemoryManager handles persistent storage and retrieval of context-aware information:

    class MemoryManager implements IMemoryManager {    runtime: IAgentRuntime;    tableName: string;    // Create new memories with embeddings    async createMemory(memory: Memory, unique = false): Promise<void> {        if (!memory.embedding) {            memory.embedding = await embed(this.runtime, memory.content.text);        }        await this.runtime.databaseAdapter.createMemory(            memory,            this.tableName,            unique,        );    }    // Semantic search with embeddings    async searchMemoriesByEmbedding(        embedding: number[],        opts: {            match_threshold?: number;            count?: number;            roomId: UUID;            unique?: boolean;        },    ): Promise<Memory[]> {        return this.runtime.databaseAdapter.searchMemories({            tableName: this.tableName,            roomId: opts.roomId,            embedding,            match_threshold: opts.match_threshold ?? 0.8,            match_count: opts.count ?? 10,            unique: opts.unique ?? false,        });    }}

### Context System[​](#context-system "Direct link to Context System")

The context system manages state composition and template handling:

    // Template compositionexport const composeContext = ({    state,    template,}: {    state: State;    template: string;}): string => {    return template.replace(/{{\w+}}/g, (match) => {        const key = match.replace(/{{|}}/g, "");        return state[key] ?? "";    });};// Header handlingexport const addHeader = (header: string, body: string): string => {    return body.length > 0 ? `${header ? header + "\n" : header}${body}\n` : "";};

### Action System[​](#action-system "Direct link to Action System")

Actions define the available behaviors and responses:

    interface Action {    name: string;    similes: string[];    description: string;    examples: MessageExample[][];    validate: (        runtime: IAgentRuntime,        message: Memory,        state?: State,    ) => Promise<boolean>;    handler: (        runtime: IAgentRuntime,        message: Memory,        state?: State,        options?: any,        callback?: HandlerCallback,    ) => Promise<void>;}// Example action implementationconst generateImageAction: Action = {    name: "GENERATE_IMAGE",    similes: ["CREATE_IMAGE", "MAKE_PICTURE"],    description: "Generate an AI image from text",    validate: async (runtime, message) => {        return (            !!runtime.getSetting("ANTHROPIC_API_KEY") &&            !!runtime.getSetting("TOGETHER_API_KEY")        );    },    handler: async (runtime, message, state, options, callback) => {        const images = await generateImage(            { prompt: message.content.text },            runtime,        );        const captions = await Promise.all(            images.data.map((image) =>                generateCaption({ imageUrl: image }, runtime),            ),        );        callback?.(            {                text: "Generated images",                attachments: images.data.map((image, i) => ({                    id: crypto.randomUUID(),                    url: image,                    title: "Generated image",                    description: captions[i].title,                })),            },            [],        );    },};

### Evaluation System[​](#evaluation-system "Direct link to Evaluation System")

Evaluators assess messages and guide agent behavior:

    interface Evaluator {    name: string;    similes: string[];    alwaysRun?: boolean;    validate: (        runtime: IAgentRuntime,        message: Memory,        state?: State,    ) => Promise<boolean>;    handler: (runtime: IAgentRuntime, message: Memory) => Promise<void>;}// Example evaluatorconst factEvaluator: Evaluator = {    name: "EVALUATE_FACTS",    similes: ["CHECK_FACTS"],    alwaysRun: true,    validate: async (runtime, message) => {        return message.content.text.includes("fact:");    },    handler: async (runtime, message) => {        const facts = await runtime.loreManager.searchMemories({            text: message.content.text,            threshold: 0.8,        });        if (facts.length > 0) {            await runtime.messageManager.createMemory({                content: {                    text: `Verified fact: ${facts[0].content.text}`,                },                roomId: message.roomId,                userId: runtime.agentId,            });        }    },};

### State Management[​](#state-management "Direct link to State Management")

The state system maintains conversation context and agent knowledge:

    interface State {    // Agent identity    agentId: UUID;    agentName: string;    bio: string;    lore: string;    adjective?: string;    // Conversation context    senderName?: string;    actors: string;    actorsData: Actor[];    recentMessages: string;    recentMessagesData: Memory[];    // Objectives    goals: string;    goalsData: Goal[];    // Behavioral guidance    actions: string;    actionNames: string;    evaluators: string;    evaluatorNames: string;    // Additional context    providers: string;    attachments: string;    characterPostExamples?: string;    characterMessageExamples?: string;}

Service Architecture[​](#service-architecture "Direct link to Service Architecture")
------------------------------------------------------------------------------------

The core implements a service-based architecture:

    // Service base classclass Service {    static serviceType: ServiceType;    async initialize(        device: string | null,        runtime: IAgentRuntime,    ): Promise<void>;}// Service registryclass ServiceRegistry {    private services = new Map<ServiceType, Service>();    registerService(service: Service): void {        const type = (service as typeof Service).serviceType;        if (this.services.has(type)) {            console.warn(`Service ${type} already registered`);            return;        }        this.services.set(type, service);    }    getService<T>(type: ServiceType): T | null {        return (this.services.get(type) as T) || null;    }}

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

### Memory Management[​](#memory-management "Direct link to Memory Management")

    // Use unique flags for important memoriesawait memoryManager.createMemory(memory, true);// Search with appropriate thresholdsconst similar = await memoryManager.searchMemoriesByEmbedding(embedding, {    match_threshold: 0.8,    count: 10,});// Clean up old memories periodicallyawait memoryManager.removeAllMemories(roomId, tableName);

### State Composition[​](#state-composition "Direct link to State Composition")

    // Compose full stateconst state = await runtime.composeState(message, {    additionalContext: "Custom context",});// Update with recent messagesconst updatedState = await runtime.updateRecentMessageState(state);// Add custom providersstate.providers = addHeader(    "# Additional Information",    await Promise.all(providers.map((p) => p.get(runtime, message))).join("\n"),);

### Service Management[​](#service-management "Direct link to Service Management")

    // Service initializationclass CustomService extends Service {    static serviceType = ServiceType.CUSTOM;    async initialize(device: string | null, runtime: IAgentRuntime) {        await this.setupDependencies();        await this.validateConfig();        await this.connect();    }    async cleanup() {        await this.disconnect();        await this.clearResources();    }}// Service registrationruntime.registerService(new CustomService());// Service usageconst service = runtime.getService<CustomService>(ServiceType.CUSTOM);

Error Handling[​](#error-handling "Direct link to Error Handling")
------------------------------------------------------------------

Implement proper error handling throughout:

    try {    await runtime.processActions(message, responses, state);} catch (error) {    if (error instanceof TokenError) {        await this.refreshToken();    } else if (error instanceof DatabaseError) {        await this.reconnectDatabase();    } else {        console.error("Unexpected error:", error);        throw error;    }}

Advanced Features[​](#advanced-features "Direct link to Advanced Features")
---------------------------------------------------------------------------

### Custom Memory Types[​](#custom-memory-types "Direct link to Custom Memory Types")

    // Create specialized memory managersclass DocumentMemoryManager extends MemoryManager {    constructor(runtime: IAgentRuntime) {        super({            runtime,            tableName: "documents",            useCache: true,        });    }    async processDocument(doc: Document): Promise<void> {        const chunks = await splitChunks(doc.content);        for (const chunk of chunks) {            await this.createMemory({                content: { text: chunk },                metadata: {                    documentId: doc.id,                    section: chunk.section,                },            });        }    }}

### Enhanced Embeddings[​](#enhanced-embeddings "Direct link to Enhanced Embeddings")

    // Advanced embedding handlingasync function enhancedEmbed(    runtime: IAgentRuntime,    text: string,    opts: {        model?: string;        dimensions?: number;        pooling?: "mean" | "max";    },): Promise<number[]> {    // Get cached embedding if available    const cached = await runtime.databaseAdapter.getCachedEmbeddings({        query_input: text,        query_threshold: 0.95,    });    if (cached.length > 0) {        return cached[0].embedding;    }    // Generate new embedding    return embed(runtime, text, opts);}

### State Persistence[​](#state-persistence "Direct link to State Persistence")

    class StateManager {    async saveState(state: State): Promise<void> {        await this.runtime.databaseAdapter.createMemory(            {                content: {                    type: "state",                    data: state,                },                roomId: state.roomId,                userId: state.agentId,            },            "states",        );    }    async loadState(roomId: UUID): Promise<State | null> {        const states = await this.runtime.databaseAdapter.getMemories({            roomId,            tableName: "states",            count: 1,        });        return states[0]?.content.data || null;    }}

*   [API Reference](https://elizaos.github.io/eliza/api/classes/AgentRuntime/)</content>
</page>

<page>
  <title>🔌 Client Packages | eliza</title>
  <url>https://elizaos.github.io/eliza/docs/packages/clients/</url>
  <content>Overview[​](#overview "Direct link to Overview")
------------------------------------------------

Eliza's client packages enable integration with various platforms and services. Each client provides a standardized interface for sending and receiving messages, handling media, and interacting with platform-specific features.

### Architecture Overview[​](#architecture-overview "Direct link to Architecture Overview")

Available Clients[​](#available-clients "Direct link to Available Clients")
---------------------------------------------------------------------------

*   **Discord** (`@eliza/client-discord`) - Full Discord bot integration
*   **Twitter** (`@eliza/client-twitter`) - Twitter bot and interaction handling
*   **Telegram** (`@eliza/client-telegram`) - Telegram bot integration
*   **Direct** (`@eliza/client-direct`) - Direct API interface for custom integrations
*   **Auto** (`@eliza/client-auto`) - Automated trading and interaction client

* * *

Installation[​](#installation "Direct link to Installation")
------------------------------------------------------------

    # Discordpnpm add @eliza/client-discord# Twitterpnpm add @eliza/client-twitter# Telegrampnpm add @eliza/client-telegram# Direct APIpnpm add @eliza/client-direct# Auto Clientpnpm add @eliza/client-auto

* * *

Discord Client[​](#discord-client "Direct link to Discord Client")
------------------------------------------------------------------

The Discord client provides full integration with Discord's features including voice, reactions, and attachments.

### Basic Setup[​](#basic-setup "Direct link to Basic Setup")

    import { DiscordClientInterface } from "@eliza/client-discord";// Initialize clientconst client = await DiscordClientInterface.start(runtime);// Configuration in .envDISCORD_APPLICATION_ID = your_app_id;DISCORD_API_TOKEN = your_bot_token;

### Features[​](#features "Direct link to Features")

*   Voice channel integration
*   Message attachments
*   Reactions handling
*   Media transcription
*   Room management

### Voice Integration[​](#voice-integration "Direct link to Voice Integration")

    class VoiceManager {  // Join a voice channel  async handleJoinChannelCommand(interaction) {    await this.joinVoiceChannel(channel);  }  // Handle voice state updates  async handleVoiceStateUpdate(oldState, newState) {    if (newState.channelId) {      await this.handleUserJoinedChannel(newState);    }  }}

### Message Handling[​](#message-handling "Direct link to Message Handling")

    class MessageManager {  async handleMessage(message) {    // Ignore bot messages    if (message.author.bot) return;    // Process attachments    if (message.attachments.size > 0) {      await this.processAttachments(message);    }    // Generate response    await this.generateResponse(message);  }}

Twitter Client[​](#twitter-client "Direct link to Twitter Client")
------------------------------------------------------------------

The Twitter client enables posting, searching, and interacting with Twitter users.

### Basic Setup[​](#basic-setup-1 "Direct link to Basic Setup")

    import { TwitterClientInterface } from "@eliza/client-twitter";// Initialize clientconst client = await TwitterClientInterface.start(runtime);// Configuration in .envTWITTER_USERNAME = your_username;TWITTER_PASSWORD = your_password;TWITTER_EMAIL = your_email;

### Components[​](#components "Direct link to Components")

*   **PostClient**: Handles creating and managing posts
*   **SearchClient**: Handles search functionality
*   **InteractionClient**: Manages user interactions

### Post Management[​](#post-management "Direct link to Post Management")

    class TwitterPostClient {  async createPost(content: string) {    return await this.post({      text: content,      media: await this.processMedia(),    });  }  async replyTo(tweetId: string, content: string) {    return await this.post({      text: content,      reply: { in_reply_to_tweet_id: tweetId },    });  }}

### Search Features[​](#search-features "Direct link to Search Features")

    class TwitterSearchClient {  async searchTweets(query: string) {    return await this.search({      query,      filters: {        recency: "recent",        language: "en",      },    });  }}

Telegram Client[​](#telegram-client "Direct link to Telegram Client")
---------------------------------------------------------------------

The Telegram client provides messaging and bot functionality for Telegram.

### Basic Setup[​](#basic-setup-2 "Direct link to Basic Setup")

    import { TelegramClientInterface } from "@eliza/client-telegram";// Initialize clientconst client = await TelegramClientInterface.start(runtime);// Configuration in .envTELEGRAM_BOT_TOKEN = your_bot_token;

### Message Management[​](#message-management "Direct link to Message Management")

    class TelegramClient {  async handleMessage(message) {    // Process message content    const content = await this.processMessage(message);    // Generate response    const response = await this.generateResponse(content);    // Send response    await this.sendMessage(message.chat.id, response);  }}

Direct Client[​](#direct-client "Direct link to Direct Client")
---------------------------------------------------------------

The Direct client provides a REST API interface for custom integrations.

### Basic Setup[​](#basic-setup-3 "Direct link to Basic Setup")

    import { DirectClientInterface } from "@eliza/client-direct";// Initialize clientconst client = await DirectClientInterface.start(runtime);

### API Endpoints[​](#api-endpoints "Direct link to API Endpoints")

    class DirectClient {  constructor() {    // Message endpoint    this.app.post("/:agentId/message", async (req, res) => {      const response = await this.handleMessage(req.body);      res.json(response);    });    // Image generation endpoint    this.app.post("/:agentId/image", async (req, res) => {      const images = await this.generateImage(req.body);      res.json(images);    });  }}

Auto Client[​](#auto-client "Direct link to Auto Client")
---------------------------------------------------------

The Auto client enables automated interactions and trading.

### Basic Setup[​](#basic-setup-4 "Direct link to Basic Setup")

    import { AutoClientInterface } from "@eliza/client-auto";// Initialize clientconst client = await AutoClientInterface.start(runtime);

### Automated Trading[​](#automated-trading "Direct link to Automated Trading")

    class AutoClient {  constructor(runtime: IAgentRuntime) {    this.runtime = runtime;    // Start trading loop    this.interval = setInterval(      () => {        this.makeTrades();      },      60 * 60 * 1000,    ); // 1 hour interval  }  async makeTrades() {    // Get recommendations    const recommendations = await this.getHighTrustRecommendations();    // Analyze tokens    const analysis = await this.analyzeTokens(recommendations);    // Execute trades    await this.executeTrades(analysis);  }}

Common Features[​](#common-features "Direct link to Common Features")
---------------------------------------------------------------------

### Message Handling[​](#message-handling-1 "Direct link to Message Handling")

All clients implement standard message handling:

    interface ClientInterface {  async handleMessage(message: Message): Promise<void>;  async generateResponse(context: Context): Promise<Response>;  async sendMessage(destination: string, content: Content): Promise<void>;}

### Media Processing[​](#media-processing "Direct link to Media Processing")

    interface MediaProcessor {  async processImage(image: Image): Promise<ProcessedImage>;  async processVideo(video: Video): Promise<ProcessedVideo>;  async processAudio(audio: Audio): Promise<ProcessedAudio>;}

### Error Handling[​](#error-handling "Direct link to Error Handling")

    class BaseClient {  protected async handleError(error: Error) {    console.error("Client error:", error);    if (error.code === "RATE_LIMIT") {      await this.handleRateLimit(error);    } else if (error.code === "AUTH_FAILED") {      await this.refreshAuth();    }  }}

* * *

Best Practices[​](#best-practices "Direct link to Best Practices")
------------------------------------------------------------------

1.  **Authentication**
    
    *   Store credentials securely in environment variables
    *   Implement token refresh mechanisms
    *   Handle authentication errors gracefully
2.  **Rate Limiting**
    
    *   Implement exponential backoff
    *   Track API usage
    *   Queue messages during rate limits
3.  **Error Handling**
    
    *   Log errors with context
    *   Implement retry logic
    *   Handle platform-specific errors
4.  **Media Processing**
    
    *   Validate media before processing
    *   Handle different file formats
    *   Implement size limits

### Error Handling[​](#error-handling-1 "Direct link to Error Handling")

    class BaseClient {  protected async handleError(error: Error) {    if (error.code === "RATE_LIMIT") {      await this.handleRateLimit(error);    } else if (error.code === "AUTH_FAILED") {      await this.refreshAuth();    } else if (error.code === "NETWORK_ERROR") {      await this.reconnect();    }    // Log error    console.error("Client error:", {      type: error.name,      message: error.message,      code: error.code,      stack: error.stack,    });  }}

### Resource Management[​](#resource-management "Direct link to Resource Management")

    class ClientManager {  private async cleanup() {    // Close connections    await Promise.all(this.connections.map((conn) => conn.close()));    // Clear caches    this.cache.clear();    // Cancel timers    this.timers.forEach((timer) => clearInterval(timer));  }  private async reconnect() {    await this.cleanup();    await wait(this.calculateBackoff());    await this.initialize();  }}

### Rate Limiting[​](#rate-limiting "Direct link to Rate Limiting")

    class RateLimiter {  private async handleRateLimit(error: RateLimitError) {    const delay = this.calculateBackoff(error);    await wait(delay);    return this.retryRequest();  }  private calculateBackoff(error: RateLimitError): number {    return Math.min(this.baseDelay * Math.pow(2, this.attempts), this.maxDelay);  }}

* * *

Performance Optimization[​](#performance-optimization "Direct link to Performance Optimization")
------------------------------------------------------------------------------------------------

### Connection Management[​](#connection-management "Direct link to Connection Management")

    class ClientManager {  private reconnect() {    await this.disconnect();    await wait(this.backoff());    await this.connect();  }}

### Message Queuing[​](#message-queuing "Direct link to Message Queuing")

    class MessageQueue {  async queueMessage(message: Message) {    await this.queue.push(message);    this.processQueue();  }}

Troubleshooting[​](#troubleshooting "Direct link to Troubleshooting")
---------------------------------------------------------------------

### Common Issues[​](#common-issues "Direct link to Common Issues")

1.  **Authentication Failures**

    // Implement token refreshasync refreshAuth() {  const newToken = await this.requestNewToken();  await this.updateToken(newToken);}

2.  **Rate Limits**

    // Handle rate limitingasync handleRateLimit(error) {  const delay = this.calculateBackoff(error);  await wait(delay);  return this.retryRequest();}

3.  **Connection Issues**

    // Implement reconnection logicasync handleDisconnect() {  await this.reconnect({    maxAttempts: 5,    backoff: 'exponential'  });}

4.  **Message Processing Failure**

    async processMessage(message) {  try {    return await this.messageProcessor(message);  } catch (error) {    if (error.code === "INVALID_FORMAT") {      return this.handleInvalidFormat(message);    }    throw error;  }}

*   [Error Handling](https://elizaos.github.io/eliza/docs/packages/core/)</content>
</page>